<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECG æŸ¥çœ‹å™¨ - å¿ƒç”µå›¾æ³¢å½¢å¯è§†åŒ–</title>
    <meta name="description" content="ç°ä»£åŒ–å¿ƒç”µå›¾æ•°æ®æŸ¥çœ‹å™¨ï¼Œæ”¯æŒ HDF5 æ–‡ä»¶åŠ è½½ã€å¤šå¯¼è”æ˜¾ç¤ºã€äº¤äº’å¼åˆ†æ">

    <!--
        âš ï¸ æµè§ˆå™¨å…¼å®¹æ€§è¯´æ˜ / Browser Compatibility Notice
        
        æœ¬é¡¹ç›®ä»…é’ˆå¯¹ Google Chrome æµè§ˆå™¨è¿›è¡Œä¼˜åŒ–å’Œæµ‹è¯•ã€‚
        ä¸å¯¹å…¶ä»–æµè§ˆå™¨ï¼ˆSafariã€Firefoxã€Edge ç­‰ï¼‰æä¾›å…¼å®¹æ€§ä¿è¯ã€‚
        
        å»ºè®®ä½¿ç”¨ Chrome æœ€æ–°ç‰ˆæœ¬ä»¥è·å¾—æœ€ä½³ä½“éªŒã€‚
        
        This project is optimized and tested for Google Chrome only.
        No compatibility guarantee for other browsers (Safari, Firefox, Edge, etc.).
    -->

    <!-- Plotly.js for visualization (æœ¬åœ°ç‰ˆæœ¬ï¼Œé¿å… CDN åŠ è½½é—®é¢˜) -->
    <script src="/vendor/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        // Largest Triangle Three Buckets (LTTB) Downsampling Algorithm
        // Adapted for inline usage to avoid 404 errors
        // Min-Max Downsampling Algorithm (Oscilloscope Style)
        // Preserves all peaks and valleys (Extrema)
        const MinMax = {
            process: function (data, threshold, hasX = false) {
                const dataLength = data.length;
                if (threshold >= dataLength || threshold === 0) {
                    return data;
                }

                // We need 2 points per bucket (min and max)
                // So effective buckets = threshold / 2
                const buckets = Math.floor(threshold / 2);
                const every = dataLength / buckets;

                const sampled = [];
                let sampledIndex = 0;

                let a = 0;
                for (let i = 0; i < buckets; i++) {
                    const rangeFrom = Math.floor(i * every);
                    const rangeTo = Math.floor((i + 1) * every);

                    let minVal = Infinity, maxVal = -Infinity;
                    let minIdx = 0, maxIdx = 0;
                    let minX = 0, maxX = 0;

                    for (let j = rangeFrom; j < rangeTo && j < dataLength; j++) {
                        const val = hasX ? data[j][1] : data[j];
                        if (val < minVal) { minVal = val; minIdx = j; if (hasX) minX = data[j][0]; }
                        if (val > maxVal) { maxVal = val; maxIdx = j; if (hasX) maxX = data[j][0]; }
                    }

                    // Push both min and max, in order of appearance if possible
                    // For simple drawing, order might not matter as much if pixels are close, 
                    // but preserving temporal order is better.
                    if (minIdx < maxIdx) {
                        if (hasX) {
                            sampled[sampledIndex++] = [minX, minVal];
                            sampled[sampledIndex++] = [maxX, maxVal];
                        } else {
                            sampled[sampledIndex++] = [minIdx, minVal];
                            sampled[sampledIndex++] = [maxIdx, maxVal];
                        }
                    } else {
                        if (hasX) {
                            sampled[sampledIndex++] = [maxX, maxVal];
                            sampled[sampledIndex++] = [minX, minVal];
                        } else {
                            sampled[sampledIndex++] = [maxIdx, maxVal];
                            sampled[sampledIndex++] = [minIdx, minVal];
                        }
                    }
                }
                return sampled;
            }
        };


    </script>

    <!-- h5wasm for fast client-side HDF5 reading -->
    <script type="module">
        import h5wasm from "https://cdn.jsdelivr.net/npm/h5wasm@latest/dist/esm/hdf5_hl.js";
        window.h5wasmModule = h5wasm;
        (async () => {
            try {
                window.h5wasmReady = await h5wasm.ready;
                window.h5wasm = h5wasm;
                console.log("âœ… h5wasm initialized");
            } catch (e) {
                console.warn("h5wasm init failed, using backend fallback:", e);
            }
        })();
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">

    <style>
        :root {
            /* æ·±è‰²ä¸»é¢˜é…è‰² */
            --bg-primary: #0f0f13;
            --bg-secondary: #16161d;
            --bg-tertiary: #1e1e28;
            --bg-card: #1a1a24;
            --bg-hover: #252533;

            --text-primary: #f0f0f5;
            --text-secondary: #a0a0b0;
            --text-muted: #6b6b7b;

            --accent-primary: #6366f1;
            --accent-secondary: #818cf8;
            --accent-glow: rgba(99, 102, 241, 0.3);

            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;

            --border-color: #2a2a3a;
            --border-radius: 12px;

            /* ECG æ³¢å½¢é¢œè‰² - æ¸å˜è‰²ç³» */
            --ch1: #22d3ee;
            --ch2: #34d399;
            --ch3: #a78bfa;
            --ch4: #f472b6;
            --ch5: #fb923c;
            --ch6: #facc15;
            --ch7: #4ade80;
            --ch8: #60a5fa;
            --ch9: #e879f9;
            --ch10: #f87171;
            --ch11: #2dd4bf;
            --ch12: #c084fc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        /* ä¸»å¸ƒå±€ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* é¡¶éƒ¨å·¥å…·æ  */
        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            gap: 16px;
            flex-shrink: 0;
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--text-primary);
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .logo-text {
            font-weight: 700;
            font-size: 18px;
            letter-spacing: -0.5px;
        }

        .logo-text span {
            color: var(--accent-secondary);
        }

        .divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
        }

        .toolbar-center {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* æŒ‰é’®æ ·å¼ */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            border: none;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px var(--accent-glow);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
        }

        .btn-icon {
            padding: 8px;
            background: transparent;
            color: var(--text-secondary);
            border: none;
        }

        .btn-icon:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* ä¸»å†…å®¹åŒº */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* å·¦ä¾§é¢æ¿ */
        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
            transition: width 0.3s ease, opacity 0.3s ease;
        }

        /* è‡ªåŠ¨éšè—çŠ¶æ€ */
        .sidebar.auto-hidden {
            width: 40px;
            overflow: visible;
        }

        .sidebar.auto-hidden .sidebar-section {
            display: none;
        }

        .sidebar.auto-hidden:hover {
            width: 280px;
        }

        .sidebar.auto-hidden:hover .sidebar-section {
            display: flex;
        }

        .sidebar-section {
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        /* å¯æŠ˜å éƒ¨åˆ† */
        .sidebar-section.collapsible .sidebar-header {
            cursor: pointer;
            user-select: none;
        }

        .sidebar-section.collapsible .sidebar-header:hover {
            background: var(--bg-hover);
        }

        .collapse-icon {
            font-size: 10px;
            transition: transform 0.2s ease;
        }

        .sidebar-section.collapsible .sidebar-content.collapsed {
            display: none;
        }

        .sidebar-section.collapsible .sidebar-content.collapsed+.collapse-icon,
        .sidebar-section.collapsible:has(.sidebar-content.collapsed) .collapse-icon {
            transform: rotate(-90deg);
        }

        /* æ ‡æ³¨éƒ¨åˆ†å æ®å‰©ä½™ç©ºé—´ */
        .sidebar-section.annotation-section {
            flex: 1;
            min-height: 0;
            overflow: hidden;
            border-bottom: none;
        }

        .sidebar-section.annotation-section .sidebar-content {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
            padding: 0;
        }

        .channel-list {
            padding: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
        }

        .sidebar-content {
            padding: 6px 10px 10px;
        }

        /* æ–‡ä»¶ä¿¡æ¯å¡ç‰‡ */
        .file-info {
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            padding: 14px;
        }

        .file-info-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 13px;
        }

        .file-info-label {
            color: var(--text-secondary);
        }

        .file-info-value {
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }

        /* é€šé“åˆ—è¡¨ */
        .channel-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .channel-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .channel-item:hover {
            background: var(--bg-hover);
        }

        .channel-item.active {
            background: var(--bg-tertiary);
        }

        .channel-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .channel-name {
            flex: 1;
            font-size: 13px;
            font-weight: 500;
        }

        .channel-tag {
            font-size: 9px;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 4px;
            font-weight: 500;
        }

        .channel-tag.raw {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        .channel-tag.computed {
            background: rgba(168, 85, 247, 0.2);
            color: #c084fc;
        }

        .channel-toggle {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.15s ease;
        }

        .channel-item.active .channel-toggle {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* æ ‡æ³¨åˆ—è¡¨ */
        .annotation-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 12px;
            /* ç§»é™¤å›ºå®š max-heightï¼Œè®©çˆ¶å®¹å™¨ sidebar-content æ§åˆ¶æ»šåŠ¨ */
        }

        .annotation-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s ease;
            font-size: 13px;
        }

        .annotation-item:hover {
            background: var(--bg-hover);
        }

        .annotation-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--accent-secondary);
            min-width: 60px;
        }

        .annotation-label {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* æ³¢å½¢æ˜¾ç¤ºåŒºåŸŸ */
        .waveform-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            overflow: hidden;
            position: relative;
            /* å…³é”®ï¼šè®©ä¸Šä¼ åŒºåŸŸç›¸å¯¹äºæ­¤å®¹å™¨å®šä½ */
        }

        #ecg-plot {
            flex: 1;
            width: 100%;
        }

        /* æ—¶é—´è½´æ§åˆ¶ */
        .timeline-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }

        .time-display {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            padding: 6px 12px;
            border-radius: 6px;
        }

        .time-display strong {
            color: var(--text-primary);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .zoom-level {
            font-size: 12px;
            color: var(--text-muted);
            min-width: 50px;
            text-align: center;
        }

        /* ä¸Šä¼ æ‹–æ‹½åŒºåŸŸ */
        .upload-zone {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary);
            z-index: 10;
            /* é™ä½ z-indexï¼Œåªè¦†ç›–æ³¢å½¢åŒºåŸŸ */
        }

        .upload-zone.hidden {
            display: none;
        }

        .upload-box {
            text-align: center;
            padding: 60px 80px;
            border: 2px dashed var(--border-color);
            border-radius: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-box:hover,
        .upload-box.dragover {
            border-color: var(--accent-primary);
            background: rgba(99, 102, 241, 0.05);
        }

        .upload-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.8;
        }

        .upload-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .upload-subtitle {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 24px;
        }

        .upload-hint {
            font-size: 12px;
            color: var(--text-muted);
        }

        /* åŠ è½½çŠ¶æ€ */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 15, 19, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--bg-tertiary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* æµ‹é‡å·¥å…·è¦†ç›–å±‚ï¼ˆæœªæ¥æ‰©å±•ï¼‰ */
        .measure-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        /* æç¤º Toast */
        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-tertiary);
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 2000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: var(--error);
        }

        .toast.warning {
            border-color: var(--warning);
        }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }

            .toolbar {
                flex-wrap: wrap;
                padding: 10px;
            }
        }

        /* éšè—æ–‡ä»¶è¾“å…¥ */
        #file-input {
            display: none;
        }

        /* ç©ºçŠ¶æ€ */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-hover);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-color);
        }

        /* é€šé“å³é”®èœå• */
        /* é€šé“å³é”®èœå• - æ¨ªå‘é•¿æ¡å½¢å¸ƒå±€ */
        .channel-context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            z-index: 10000;
            display: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            white-space: nowrap;
        }

        .channel-context-menu.visible {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .channel-context-menu .menu-header {
            font-weight: 600;
            font-size: 12px;
            color: var(--accent-color);
            padding-right: 12px;
            border-right: 1px solid var(--border-color);
        }

        .channel-context-menu .menu-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .channel-context-menu label {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .channel-context-menu select {
            padding: 3px 6px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            min-width: 70px;
        }

        .channel-context-menu .menu-actions {
            display: flex;
            gap: 6px;
            padding-left: 12px;
            border-left: 1px solid var(--border-color);
        }

        .channel-context-menu button {
            padding: 4px 10px;
            font-size: 11px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }

        .channel-context-menu .btn-apply {
            background: var(--accent-color);
            color: white;
        }

        .channel-context-menu .btn-cancel {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .channel-filter-badge {
            font-size: 9px;
            padding: 1px 4px;
            border-radius: 3px;
            background: var(--accent-color);
            color: white;
            margin-left: 4px;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- é¡¶éƒ¨å·¥å…·æ  -->
        <header class="toolbar">
            <div class="toolbar-left">
                <!-- ä¾§è¾¹æ åˆ‡æ¢æŒ‰é’® -->
                <button class="btn btn-icon" onclick="toggleSidebar()" title="åˆ‡æ¢ä¾§è¾¹æ " style="margin-right: 4px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7" id="sidebar-icon-path" />
                    </svg>
                </button>
                <!-- è‡ªåŠ¨éšè—åˆ‡æ¢æŒ‰é’® -->
                <button class="btn btn-icon" id="btn-auto-hide" onclick="toggleAutoHide()" title="å¯ç”¨è‡ªåŠ¨éšè—"
                    style="margin-right: 4px; font-size: 12px; padding: 4px;">
                    ğŸ“Œ
                </button>

                <a href="/" class="logo" style="gap: 4px;">
                    <div class="logo-icon" style="font-size: 16px;">ğŸ’“</div>
                    <span class="logo-text" style="font-size: 14px;">ECG</span>
                </a>
                <div class="divider" style="margin: 0 8px;"></div>
                <button class="btn btn-primary" id="btn-open" onclick="triggerFileUpload()"
                    style="font-size: 11px; padding: 4px 8px;">
                    ğŸ“‚ æ‰“å¼€
                </button>
                <div class="file-operations" style="display: flex; gap: 4px;">
                    <button class="btn btn-secondary" id="btn-export-png" onclick="exportImage()"
                        style="font-size: 11px; padding: 4px 8px;">
                        ğŸ“· å¯¼å‡º
                    </button>
                    <button class="btn btn-secondary" id="btn-export-csv" onclick="exportCSV()"
                        style="font-size: 11px; padding: 4px 8px;">
                        ğŸ“Š CSV
                    </button>
                </div>
            </div>

            <div class="toolbar-center">
                <span id="patient-info" style="font-size: 10px; color: #ffffff;"></span>
            </div>

            <div class="toolbar-right">
                <label
                    style="display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer; color: var(--text-secondary);">
                    <input type="checkbox" id="smoothing-toggle" checked onchange="toggleSmoothing()">
                    <span style="font-weight: 500;">âœ¨ å¹³æ»‘</span>
                </label>
                <div class="divider"></div>
                <!-- åˆ†é¡µæ§ä»¶ -->
                <div id="pagination-controls"
                    style="display: none; align-items: center; gap: 4px; margin-right: 8px; padding-right: 8px; border-right: 1px solid var(--border-color);">
                    <span style="font-size: 10px; color: var(--text-secondary);">é€šé“:</span>
                    <input type="number" id="channels-per-page" value="12" min="1" max="500"
                        style="width: 40px; padding: 2px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); text-align: center; font-size: 11px;"
                        onchange="updateChannelsPerPage(this.value)">

                    <div style="display: flex; align-items: center; gap: 2px;">
                        <button class="btn btn-icon" onclick="changePage(-1)" title="ä¸Šä¸€é¡µ"
                            style="padding: 2px 4px; font-size: 10px;">â—€</button>
                        <span id="page-info"
                            style="font-size: 10px; font-variant-numeric: tabular-nums; min-width: 30px; text-align: center;">1/1</span>
                        <button class="btn btn-icon" onclick="changePage(1)" title="ä¸‹ä¸€é¡µ"
                            style="padding: 2px 4px; font-size: 10px;">â–¶</button>
                    </div>
                </div>

                <!-- é€Ÿåº¦é€‰æ‹©å™¨ -->
                <div
                    style="display: flex; align-items: center; gap: 4px; margin-right: 8px; padding-right: 8px; border-right: 1px solid var(--border-color);">
                    <span style="font-size: 10px; color: var(--text-secondary);">é€Ÿåº¦:</span>
                    <select id="speed-select" onchange="updateSpeed(this.value)"
                        style="padding: 2px 4px; font-size: 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary);">
                        <option value="25">25</option>
                        <option value="50" selected>50</option>
                        <option value="75">75</option>
                        <option value="100">100</option>
                        <option value="150">150</option>
                        <option value="200">200</option>
                        <option value="300">300</option>
                        <option value="400">400</option>
                        <option value="500">500</option>
                        <option value="600">600</option>
                    </select>
                    <span style="font-size: 9px; color: var(--text-muted);">mm/s</span>
                </div>

                <!-- Notch Filter é€‰æ‹©å™¨ -->
                <div
                    style="display: flex; align-items: center; gap: 4px; margin-right: 8px; padding-right: 8px; border-right: 1px solid var(--border-color);">
                    <span style="font-size: 10px; color: var(--text-secondary);">æ»¤æ³¢:</span>
                    <select id="notch-select" onchange="updateNotchFilter(this.value)"
                        style="padding: 2px 4px; font-size: 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary);">
                        <option value="">å…³</option>
                        <option value="50" selected>50Hz</option>
                        <option value="60">60Hz</option>
                    </select>
                    <!-- å¢å¼ºé™·æ³¢å¼€å…³ -->
                    <label style="display: flex; align-items: center; gap: 3px; cursor: pointer; margin-left: 2px;"
                        title="ActiveNotchâ„¢ Enhanced: Remove Harmonics (100/150Hz) + Double Cascade">
                        <input type="checkbox" id="enhanced-notch-toggle" onchange="toggleEnhancedNotch(this.checked)"
                            style="transform: scale(0.9);">
                        <span style="font-size: 10px; color: var(--text-muted);">å¢å¼º</span>
                    </label>
                </div>

                <!-- Filter Mode é€‰æ‹©å™¨ (å…¨å±€) -->
                <div
                    style="display: flex; align-items: center; gap: 4px; margin-right: 8px; padding-right: 8px; border-right: 1px solid var(--border-color);">
                    <span style="font-size: 10px; color: var(--text-secondary);">æ¨¡å¼:</span>
                    <select id="filter-method-select" onchange="updateFilterMethod(this.value)"
                        style="padding: 2px 4px; font-size: 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary);">
                        <option value="zero_phase">Zero-phase</option>
                        <option value="causal">Causal</option>
                    </select>
                </div>

                <!-- æ¸²æŸ“å¼•æ“é€‰æ‹©å™¨ -->
                <div
                    style="display: flex; align-items: center; gap: 4px; margin-right: 8px; padding-right: 8px; border-right: 1px solid var(--border-color);">
                    <span style="font-size: 10px; color: var(--text-secondary);">æ¸²æŸ“:</span>
                    <select id="render-engine-select" onchange="updateRenderEngine(this.value)"
                        style="padding: 2px 4px; font-size: 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary);">
                        <option value="svg" selected>âœ¨ ç”»è´¨ (SVG)</option>
                        <option value="webgl">ğŸš€ æ€§èƒ½ (WebGL)</option>
                    </select>
                </div>

                <!-- é™é‡‡æ ·ç®—æ³•é€‰æ‹©å™¨ -->
                <div
                    style="display: flex; align-items: center; gap: 4px; margin-right: 8px; padding-right: 8px; border-right: 1px solid var(--border-color);">
                    <span style="font-size: 10px; color: var(--text-secondary);">ç®—æ³•:</span>
                    <select id="downsample-algo-select" onchange="updateDownsampleAlgo(this.value)"
                        style="padding: 2px 4px; font-size: 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary);">
                        <option value="lttb" selected>LTTB (è§†è§‰)</option>
                        <option value="minmax">MinMax (å³°å€¼)</option>
                    </select>
                </div>

                <!-- LP/HP é€‰æ‹©å™¨å·²ç§»è‡³å³é”®èœå•ï¼Œæ­¤å¤„éšè— -->
                <div style="display: none;">
                    <select id="lp-select">
                        <option value="">LP: Off</option>
                    </select>
                    <select id="hp-select">
                        <option value="">HP: DC</option>
                    </select>
                </div>

                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-icon" onclick="toggleGrid()" title="æ˜¾ç¤º/éšè—ç½‘æ ¼">
                        âŠ
                    </button>
                    <button class="btn btn-icon" onclick="resetView()" title="é‡ç½®è§†å›¾">
                        âŸ²
                    </button>
                    <button class="btn btn-icon" onclick="toggleDisplayMode()" title="åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼">
                        â˜°
                    </button>
                </div>
            </div>

            <div class="toolbar-right" style="display: flex; gap: 4px;">
                <a href="/" class="btn btn-secondary" style="font-size: 11px; padding: 4px 8px;">â† é¦–é¡µ</a>
            </div>
        </header>

        <div class="main-content">
            <!-- å·¦ä¾§é¢æ¿ -->
            <aside class="sidebar" id="sidebar">
                <!-- æ–‡ä»¶ä¿¡æ¯ - é»˜è®¤æŠ˜å  -->
                <div class="sidebar-section collapsible" id="section-file-info">
                    <div class="sidebar-header" onclick="toggleSection('section-file-info')">
                        <span>ğŸ“‹ æ–‡ä»¶ä¿¡æ¯</span>
                        <span class="collapse-icon" style="transform: rotate(-90deg);">â–¼</span>
                    </div>
                    <div class="sidebar-content collapsed">
                        <div class="file-info" id="file-info">
                            <div class="file-info-item" id="info-study-row" style="display: none;">
                                <span class="file-info-label">ç ”ç©¶</span>
                                <span class="file-info-value" id="info-study-id">-</span>
                            </div>
                            <div class="file-info-item" id="info-log-row" style="display: none;">
                                <span class="file-info-label">è®°å½•</span>
                                <span class="file-info-value" id="info-log-id">-</span>
                            </div>
                            <div class="file-info-item" id="info-patient-row" style="display: none;">
                                <span class="file-info-label">æ‚£è€…</span>
                                <span class="file-info-value" id="info-patient">-</span>
                            </div>
                            <div class="file-info-item">
                                <span class="file-info-label">é‡‡æ ·ç‡</span>
                                <span class="file-info-value" id="info-fs">-</span>
                            </div>
                            <div class="file-info-item">
                                <span class="file-info-label">é€šé“</span>
                                <span class="file-info-value" id="info-channels">-</span>
                            </div>
                            <div class="file-info-item">
                                <span class="file-info-label">æ—¶é•¿</span>
                                <span class="file-info-value" id="info-duration">-</span>
                            </div>
                            <div class="file-info-item">
                                <span class="file-info-label">é‡‡æ ·</span>
                                <span class="file-info-value" id="info-samples">-</span>
                            </div>
                            <div class="file-info-item" id="info-source-row" style="display: none;">
                                <span class="file-info-label">å·¥å…·</span>
                                <span class="file-info-value" id="info-source">-</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- é€šé“é€‰æ‹© - é»˜è®¤æŠ˜å  -->
                <div class="sidebar-section collapsible" id="section-channels">
                    <div class="sidebar-header" onclick="toggleSection('section-channels')">
                        <span>ğŸ“Š é€šé“</span>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <button class="btn btn-icon" onclick="event.stopPropagation(); toggleAllChannels()"
                                style="padding: 2px 6px; font-size: 10px;">å…¨é€‰</button>
                            <span class="collapse-icon">â–¼</span>
                        </div>
                    </div>
                    <div class="sidebar-content collapsed">
                        <div class="channel-list" id="channel-list">
                            <div class="empty-state" style="padding: 12px;">
                                <span style="font-size: 11px;">åŠ è½½æ–‡ä»¶åæ˜¾ç¤ºé€šé“</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- æ ‡æ³¨åˆ—è¡¨ - å æ®ä¸»è¦ç©ºé—´ -->
                <div class="sidebar-section annotation-section" id="section-annotations">
                    <div class="sidebar-header">
                        <span>ğŸ“ æ ‡æ³¨ <span id="annotation-count"
                                style="font-size: 10px; color: var(--text-muted);"></span></span>
                    </div>
                    <div style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">
                        <input type="text" id="annotation-search" placeholder="æœç´¢æ ‡æ³¨..." oninput="filterAnnotations()"
                            style="width: 100%; padding: 4px 8px; font-size: 10px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary);">
                    </div>
                    <div class="sidebar-content">
                        <div class="annotation-list" id="annotation-list">
                            <div class="empty-state" style="padding: 12px;">
                                <span style="font-size: 11px;">æ— æ ‡æ³¨æ•°æ®</span>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- æ³¢å½¢æ˜¾ç¤ºåŒºåŸŸ -->
            <main class="waveform-container">
                <div id="ecg-plot"></div>

                <!-- ä¸Šä¼ åŒºåŸŸ -->
                <div class="upload-zone" id="upload-zone">
                    <div class="upload-box" id="upload-box" onclick="triggerFileUpload()">
                        <div class="upload-icon">ğŸ“ˆ</div>
                        <div class="upload-title">æ‹–æ‹½æ•°æ®æ–‡ä»¶åˆ°è¿™é‡Œ</div>
                        <div class="upload-subtitle">æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</div>
                        <button class="btn btn-primary" style="pointer-events: none;">é€‰æ‹©æ•°æ®æ–‡ä»¶</button>
                        <div class="upload-hint" style="margin-top: 16px;">æ”¯æŒæ ¼å¼: .h5, .hdf5, .npy, .npz</div>
                    </div>
                </div>
            </main>
        </div>

        <!-- åº•éƒ¨æ—¶é—´æ§åˆ¶ -->
        <footer class="timeline-controls" id="timeline-controls" style="display: none;">
            <div class="zoom-controls">
                <button class="btn btn-icon" onclick="zoomOut()" title="ç¼©å°">â–</button>
                <span class="zoom-level" id="zoom-level">100%</span>
                <button class="btn btn-icon" onclick="zoomIn()" title="æ”¾å¤§">â•</button>
            </div>

            <div class="time-display" style="display: flex; align-items: center; gap: 4px;">
                <span style="font-size: 11px;">èµ·å§‹:</span>
                <input type="text" id="view-start-input" value="0"
                    style="width: 85px; padding: 2px 4px; font-size: 11px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); text-align: center;"
                    onchange="jumpToStartTime()">
                <input type="hidden" id="view-end-input" value="10">
            </div>

            <div class="zoom-controls">
                <button class="btn btn-icon" onclick="panLeftFast()" title="å¿«é€€ 1ç§’">â—€â—€</button>
                <button class="btn btn-icon" onclick="panLeft()" title="å‘å·¦ 0.01ç§’">â—€</button>
                <button class="btn btn-icon" onclick="panRight()" title="å‘å³ 0.01ç§’">â–¶</button>
                <button class="btn btn-icon" onclick="panRightFast()" title="å¿«è¿› 1ç§’">â–¶â–¶</button>
            </div>

            <button class="btn btn-secondary" onclick="fitToWindow()">é€‚åº”çª—å£</button>
        </footer>
    </div>

    <!-- åŠ è½½é®ç½© -->
    <div class="loading-overlay hidden" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">æ­£åœ¨åŠ è½½...</div>
    </div>

    <!-- Toast æç¤º -->
    <div class="toast" id="toast"></div>

    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
    <input type="file" id="file-input" accept=".h5,.hdf5,.he5,.hdf,.npy,.npz" onchange="handleFileSelect(event)">

    <script src="lib/h5wasm/hdf5_util.js"></script>
    <script src="lib/downsample-lttb.js"></script>
    <script>
        // ========== å…¨å±€çŠ¶æ€ ==========
        const state = {
            enableSmoothing: true, // é»˜è®¤å¼€å¯é«˜æ–¯å¾®å¹³æ»‘
            enhancedNotch: false,  // é»˜è®¤å…³é—­ ActiveNotch å¢å¼º (çº§è”è°æ³¢)
            renderEngine: 'svg',   // 'svg' (Quality) or 'webgl' (Performance)
            downsampleAlgo: 'lttb',// 'lttb' (Visual) or 'minmax' (Peak)
            fileId: null,
            metadata: null,
            annotations: [],
            activeChannels: [],
            currentData: null,
            viewStart: 0,
            viewEnd: 10,
            zoomLevel: 1,
            displayMode: 'stacked', // 'stacked' or 'overlay'
            showGrid: true,
            // åˆ†é¡µçŠ¶æ€
            channelsPerPage: 12,
            currentPage: 0,
            sidebarVisible: true,
            // æ˜¾ç¤ºé€Ÿåº¦ mm/sec
            speed: 50,
            // é™·æ³¢æ»¤æ³¢é¢‘ç‡ (null/'50'/'60')
            notchFreq: '50',
            // ä½é€šæ»¤æ³¢é¢‘ç‡ - Workmate æ ‡å‡†: 40Hz for Surface ECG
            lpFreq: '40',
            // é«˜é€šæ»¤æ³¢é¢‘ç‡ - ä¿æŒ 0.5Hz (0.05Hz å¤ªä½ä¼šåŸºçº¿æ¼‚ç§»)
            hpFreq: '0.5',
            // æ»¤æ³¢æ¨¡å¼ ('zero_phase' / 'causal')
            filterMethod: 'causal',
            // ç‰©ç†å®šæ ‡å‚æ•° (Workmate é£æ ¼)
            screenHeightMm: 320   // ç”¨æˆ·è®¾ç½®çš„å±å¹•é«˜åº¦ (mm)
            // æ³¨ï¼šamplitude (mV/cm) æ˜¯æ¯ä¸ªé€šé“ç‹¬ç«‹è®¾ç½®çš„ï¼Œåœ¨ channelFilters ä¸­
        };

        // ========== å¸ƒå±€äº¤äº’å‡½æ•° ==========
        function toggleSidebar() {
            state.sidebarVisible = !state.sidebarVisible;
            const sidebar = document.getElementById('sidebar');
            const iconPath = document.getElementById('sidebar-icon-path');

            if (state.sidebarVisible) {
                sidebar.style.display = 'flex';
                iconPath.setAttribute('d', 'M19 12H5M12 19l-7-7 7-7'); // <
            } else {
                sidebar.style.display = 'none';
                iconPath.setAttribute('d', 'M5 12h14M12 5l7 7-7 7'); // >
            }

            // è°ƒæ•´ Plotly å®½åº¦
            setTimeout(() => {
                Plotly.relayout('ecg-plot', { autosize: true });
            }, 50);
        }

        // è‡ªåŠ¨éšè—æ¨¡å¼åˆ‡æ¢
        function toggleAutoHide() {
            const sidebar = document.getElementById('sidebar');
            const btn = document.getElementById('btn-auto-hide');

            if (sidebar.classList.contains('auto-hidden')) {
                sidebar.classList.remove('auto-hidden');
                if (btn) btn.innerHTML = 'ğŸ“Œ';
                if (btn) btn.title = 'å¯ç”¨è‡ªåŠ¨éšè—';
            } else {
                sidebar.classList.add('auto-hidden');
                if (btn) btn.innerHTML = 'ğŸ“';
                if (btn) btn.title = 'ç¦ç”¨è‡ªåŠ¨éšè—';
            }

            // è°ƒæ•´ Plotly å®½åº¦
            setTimeout(() => {
                Plotly.relayout('ecg-plot', { autosize: true });
            }, 300);
        }

        function updateChannelsPerPage(val) {
            const num = parseInt(val);
            if (num > 0) {
                state.channelsPerPage = num;
                state.currentPage = 0; // é‡ç½®åˆ°ç¬¬ä¸€é¡µ
                updatePaginationUI();
                renderWaveforms(state.currentData);
            }
        }

        // æ›´æ–°æ˜¾ç¤ºé€Ÿåº¦ï¼ˆmm/secï¼‰
        function updateSpeed(val) {
            const speed = parseInt(val);
            if (speed > 0) {
                state.speed = speed;
                // é€Ÿåº¦å½±å“æ¯ç§’æ˜¾ç¤ºå¤šå°‘æ¯«ç±³ï¼Œä»è€Œå½±å“æ—¶é—´çª—å£
                // EP-WorkMate ä½¿ç”¨ 21 è‹±å¯¸æ˜¾ç¤ºå™¨ï¼Œå®½åº¦çº¦ 400mm
                // è®¡ç®—å…¬å¼ï¼šæ—¶é—´çª— = å±å¹•å®½åº¦(mm) / é€Ÿåº¦(mm/s)
                const screenWidthMm = 400; // Workmate 21å¯¸æ˜¾ç¤ºå™¨å®½åº¦
                const newRange = screenWidthMm / speed;

                // ä¿æŒèµ·å§‹æ—¶é—´ä¸å˜ï¼Œåªè°ƒæ•´ç»“æŸæ—¶é—´
                const duration = state.metadata?.duration_seconds || 60;
                state.viewEnd = Math.min(duration, state.viewStart + newRange);

                // å¦‚æœè¶…å‡ºèŒƒå›´ï¼Œè°ƒæ•´èµ·å§‹æ—¶é—´
                if (state.viewEnd - state.viewStart < newRange && state.viewEnd >= duration) {
                    state.viewStart = Math.max(0, duration - newRange);
                }

                updateViewRange();
                loadAndRenderData();
            }
        }

        // æ›´æ–°é™·æ³¢æ»¤æ³¢é¢‘ç‡
        function updateNotchFilter(val) {
            state.notchFreq = val || null;
            // åªæœ‰å½“é€‰æ‹©äº†é¢‘ç‡æ—¶ï¼Œå¢å¼ºå¼€å…³æ‰æœ‰æ•ˆï¼ˆUIä¸Šå¯ä»¥ä¸ç”¨ç¦ç”¨ï¼Œä½†é€»è¾‘ä¸Šå¦‚æ­¤ï¼‰
            loadAndRenderData();
        }

        // åˆ‡æ¢å¢å¼ºé™·æ³¢æ¨¡å¼
        function toggleEnhancedNotch(checked) {
            state.enhancedNotch = checked;
            if (state.notchFreq) {
                loadAndRenderData();
                showToast(checked ? 'å·²å¼€å¯ ActiveNotchâ„¢ å¢å¼º (çº§è”è°æ³¢)' : 'å·²åˆ‡æ¢è‡³æ ‡å‡†é™·æ³¢æ»¤æ³¢');
            }
        }

        // æ›´æ–°æ¸²æŸ“å¼•æ“
        function updateRenderEngine(val) {
            state.renderEngine = val;
            if (state.currentData) {
                renderWaveforms(state.currentData);
                showToast(val === 'svg' ? 'å·²åˆ‡æ¢è‡³é«˜ç”»è´¨æ¨¡å¼ (SVG)' : 'å·²åˆ‡æ¢è‡³é«˜æ€§èƒ½æ¨¡å¼ (WebGL)');
            }
        }

        // æ›´æ–°é™é‡‡æ ·ç®—æ³•
        function updateDownsampleAlgo(val) {
            state.downsampleAlgo = val;
            if (state.currentData) {
                renderWaveforms(state.currentData);
                showToast(val === 'lttb' ? 'å·²åˆ‡æ¢è‡³ LTTB ç®—æ³• (è§†è§‰ä¼˜åŒ–)' : 'å·²åˆ‡æ¢è‡³ Min-Max ç®—æ³• (å³°å€¼ä¿ç•™)');
            }
        }

        // æ›´æ–°ä½é€šæ»¤æ³¢é¢‘ç‡
        function updateLowpassFilter(val) {
            state.lpFreq = val || null;
            loadAndRenderData();
        }

        // æ›´æ–°é«˜é€šæ»¤æ³¢é¢‘ç‡
        function updateHighpassFilter(val) {
            state.hpFreq = val || null;
            loadAndRenderData();
        }

        // æ›´æ–°æ»¤æ³¢æ¨¡å¼
        function updateFilterMethod(val) {
            state.filterMethod = val;
            loadAndRenderData();
        }

        function changePage(delta) {
            if (!state.currentData || !state.activeChannels.length) return;

            const totalPages = Math.ceil(state.activeChannels.length / state.channelsPerPage);
            const newPage = state.currentPage + delta;

            if (newPage >= 0 && newPage < totalPages) {
                state.currentPage = newPage;
                updatePaginationUI();
                renderWaveforms(state.currentData); // é‡ç»˜ï¼ˆä¸ä»…æ˜¯æ•°æ®ï¼Œå¸ƒå±€ä¹Ÿå˜äº†ï¼‰
            }
        }

        function updatePaginationUI() {
            const activeCount = state.activeChannels.length;
            if (!activeCount) return;

            // æ›´æ–°æ¯é¡µé€šé“æ•°è¾“å…¥æ¡†çš„æœ€å¤§å€¼å’Œå½“å‰å€¼
            const channelsInput = document.getElementById('channels-per-page');
            if (channelsInput) {
                channelsInput.max = activeCount;
                // å¦‚æœå½“å‰æ¯é¡µé€šé“æ•°å¤§äºé€‰ä¸­æ•°ï¼Œè‡ªåŠ¨è°ƒæ•´
                if (state.channelsPerPage > activeCount) {
                    state.channelsPerPage = activeCount;
                    channelsInput.value = activeCount;
                }
            }

            const totalPages = Math.ceil(activeCount / state.channelsPerPage);
            const pageInfo = document.getElementById('page-info');
            if (pageInfo) {
                pageInfo.textContent = `${state.currentPage + 1}/${totalPages}`;
            }

            // ç¡®ä¿å½“å‰é¡µæœ‰æ•ˆ
            if (state.currentPage >= totalPages) {
                state.currentPage = Math.max(0, totalPages - 1);
                if (pageInfo) {
                    pageInfo.textContent = `${state.currentPage + 1}/${totalPages}`;
                }
            }

            const controls = document.getElementById('pagination-controls');
            if (controls) {
                controls.style.display = activeCount > 0 ? 'flex' : 'none';
            }
        }

        // é€šé“é¢œè‰² - ç™½è‰²æ³¢å½¢ï¼Œé€‚åˆé»‘è‰²èƒŒæ™¯
        const CHANNEL_COLORS = [
            '#ffffff', // çº¯ç™½
            '#f0f0f0', // æµ…ç°ç™½
            '#e8e8e8', // ç¨ç°
            '#ffffff',
            '#f5f5f5',
            '#eeeeee',
            '#ffffff',
            '#f8f8f8',
            '#ffffff',
            '#f0f0f0',
            '#ffffff',
            '#f5f5f5'
        ];

        // ========== å·¥å…·å‡½æ•° ==========
        function showLoading(text = 'æ­£åœ¨åŠ è½½...') {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-overlay').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }

        // åˆ‡æ¢ä¾§è¾¹æ æŠ˜å çŠ¶æ€
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (!section) return;
            const content = section.querySelector('.sidebar-content');
            const icon = section.querySelector('.collapse-icon');
            if (content) {
                content.classList.toggle('collapsed');
            }
            if (icon) {
                icon.style.transform = content.classList.contains('collapsed') ? 'rotate(-90deg)' : 'rotate(0deg)';
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(1);
            return mins > 0 ? `${mins}åˆ† ${secs}ç§’` : `${secs}ç§’`;
        }

        function formatNumber(num) {
            return num.toLocaleString();
        }

        // ========== æ–‡ä»¶æ“ä½œ ==========
        async function triggerFileUpload() {
            // ç­–ç•¥ 1: å°è¯•è°ƒç”¨åç«¯åŸç”Ÿæ–‡ä»¶å¯¹è¯æ¡†
            try {
                const response = await fetch('/api/ecg/browse');
                if (response.ok) {
                    const result = await response.json();
                    if (result.path) {
                        // ç”¨æˆ·é€‰æ‹©äº†æ–‡ä»¶ï¼Œç›´æ¥ä½¿ç”¨åç«¯æ‰“å¼€æœ¬åœ°è·¯å¾„
                        await openLocalFile(result.path);
                        return;
                    } else if (result.error) {
                        console.warn('åç«¯ Browse API é”™è¯¯:', result.error);
                        // åç«¯ä¸æ”¯æŒæˆ–å‡ºé”™ï¼Œå›é€€åˆ°å‰ç«¯æ–‡ä»¶é€‰æ‹©
                    } else {
                        // ç”¨æˆ·å–æ¶ˆäº†å¯¹è¯æ¡†
                        return;
                    }
                }
            } catch (e) {
                console.warn('åç«¯ Browse API ä¸å¯ç”¨ï¼Œå›é€€åˆ°å‰ç«¯æ–‡ä»¶é€‰æ‹©:', e);
            }

            // ç­–ç•¥ 2: å›é€€åˆ°æµè§ˆå™¨æ–‡ä»¶é€‰æ‹© (<input type="file">)
            // [FIX] å…¨å±æ¨¡å¼ä¸‹æ–‡ä»¶å¯¹è¯æ¡†å¯èƒ½è¢«é®æŒ¡ï¼Œéœ€è¦å…ˆé€€å‡ºå…¨å±
            const wasFullscreen = !!document.fullscreenElement;
            if (wasFullscreen) {
                await document.exitFullscreen();
                // ç­‰å¾…å…¨å±é€€å‡ºåŠ¨ç”»å®Œæˆ
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            document.getElementById('file-input').click();
        }

        async function openLocalFile(path) {
            showLoading('æ­£åœ¨æ‰“å¼€æœ¬åœ°æ–‡ä»¶...');
            try {
                const response = await fetch('/api/ecg/open_local', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: path })
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'æ‰“å¼€æ–‡ä»¶å¤±è´¥');
                }

                const result = await response.json();

                // ä½¿ç”¨é€šç”¨åˆå§‹åŒ–
                await initializeFileSession(result, false);

                hideLoading();
                showToast('æœ¬åœ°æ–‡ä»¶åŠ è½½æˆåŠŸ (Backend Direct)', 'success');

            } catch (error) {
                hideLoading();
                showToast(error.message, 'error');
                console.error('Open local file error:', error);
            }
        }

        async function initializeFileSession(result, isLocal) {
            // 1. æ›´æ–°æ ¸å¿ƒçŠ¶æ€
            state.fileId = result.file_id;
            state.metadata = result.metadata;
            state.isLocalFile = isLocal;

            // å¦‚æœåˆ‡æ¢åˆ°åç«¯æ¨¡å¼ï¼Œæ¸…ç† h5wasm å¥æŸ„
            if (!isLocal) {
                state.h5file = null;
                state.h5fs = null;
            }

            // 2. æ›´æ–° UI ä¿¡æ¯é¢æ¿
            updateFileInfo(result);

            // 3. å°è¯•åŠ è½½æ ‡æ³¨ (åç«¯æ¨¡å¼éœ€è¦å•ç‹¬ APIï¼Œh5wasm æ¨¡å¼åœ¨å†…éƒ¨æå–)
            if (!isLocal) {
                await loadAnnotations();
            }

            // 4. é‡ç½®è§†å›¾å‚æ•°
            state.viewStart = 0;
            // æ ¹æ®å½“å‰é€Ÿåº¦è®¡ç®—åˆå§‹æ—¶é—´çª— (é»˜è®¤ Workmate 400mm å®½åº¦)
            const screenWidthMm = 400;
            const initialRange = screenWidthMm / (state.speed || 25);
            state.viewEnd = Math.min(initialRange, state.metadata.duration_seconds || 10);

            // é»˜è®¤é€‰æ‹©æ ‡å‡† 12 å¯¼è” ECGï¼ˆæ ¹æ®é€šé“åç§°åŒ¹é…ï¼‰
            const standard12Lead = ['I', 'II', 'III', 'aVL', 'aVF', 'aVR', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
            const channelNames = state.metadata.display_channel_names || state.metadata.channel_names || [];

            // æŸ¥æ‰¾åŒ¹é…çš„é€šé“ç´¢å¼•
            const matchedIndices = [];
            for (let i = 0; i < channelNames.length; i++) {
                const name = channelNames[i].toUpperCase().replace(/\s+/g, '');
                for (const lead of standard12Lead) {
                    if (name === lead.toUpperCase() || name.endsWith(lead.toUpperCase())) {
                        matchedIndices.push(i);
                        break;
                    }
                }
            }

            // å¦‚æœæ‰¾åˆ°æ ‡å‡†å¯¼è”ï¼Œä½¿ç”¨å®ƒä»¬ï¼›å¦åˆ™å›é€€åˆ°å‰ 12 ä¸ªé€šé“
            const totalChannels = state.metadata.display_num_channels || state.metadata.num_channels;
            if (matchedIndices.length > 0) {
                state.activeChannels = matchedIndices.sort((a, b) => a - b);
            } else {
                const defaultChannels = Math.min(12, totalChannels);
                state.activeChannels = Array.from({ length: defaultChannels }, (_, i) => i);
            }

            // ä¸ºæ ‡å‡†12å¯¼è”è®¾ç½®é»˜è®¤å‚æ•° (Workmate æ ‡å‡†: HP 0.05Hz, LP 40Hz)
            state.channelFilters = {};
            for (const idx of matchedIndices) {
                state.channelFilters[idx] = { hp: '0.5', lp: '40', amplitude: '1', clipping: '' };
            }
            console.log('12å¯¼è”é»˜è®¤è®¾ç½®:', state.channelFilters);

            // åˆ†é¡µé‡ç½®
            state.currentPage = 0;
            updateChannelsPerPage(document.getElementById('channels-per-page').value); // è¿™ä¼šè§¦å‘ updatePaginationUI

            // 5. æ¸²æŸ“ä¾§è¾¹æ åˆ—è¡¨
            renderChannelList();

            // 6. æ˜¾ç¤ºä¸»ç•Œé¢æ§ä»¶
            document.getElementById('upload-zone').classList.add('hidden');
            document.getElementById('timeline-controls').style.display = 'flex';
            document.getElementById('btn-export-png').disabled = false;
            document.getElementById('btn-export-csv').disabled = false;

            // æ›´æ–°å·¥å…·æ æ‚£è€…ä¿¡æ¯
            const patientName = state.metadata.patient_name || '';
            const studyDate = state.metadata.study_date || state.metadata.date || '';
            const patientInfoEl = document.getElementById('patient-info');
            if (patientInfoEl) {
                const parts = [];
                if (patientName) parts.push(patientName);
                if (studyDate) parts.push(studyDate);
                // å¦‚æœæ²¡æœ‰æ‚£è€…ä¿¡æ¯ï¼Œæ˜¾ç¤ºæ–‡ä»¶å
                if (parts.length === 0 && result.filename) {
                    parts.push(result.filename);
                }
                patientInfoEl.textContent = parts.join(' | ');
                console.log('æ‚£è€…ä¿¡æ¯:', parts.join(' | '), 'å…ƒæ•°æ®:', state.metadata);
            }

            // 7. åŠ è½½æ³¢å½¢æ•°æ®
            await loadAndRenderData();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                uploadFile(file);
            }
        }

        // æ‹–æ‹½å¤„ç†
        const uploadBox = document.getElementById('upload-box');
        const uploadZone = document.getElementById('upload-zone');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadBox.addEventListener(eventName, e => {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        uploadBox.addEventListener('dragenter', () => uploadBox.classList.add('dragover'));
        uploadBox.addEventListener('dragleave', () => uploadBox.classList.remove('dragover'));
        uploadBox.addEventListener('drop', e => {
            uploadBox.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                uploadFile(files[0]);
            }
        });

        async function uploadFile(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            const isH5 = ['h5', 'hdf5', 'he5', 'hdf'].includes(ext);
            const sizeMB = file.size / 1024 / 1024;
            const MAX_LOCAL_SIZE_MB = 2048; // è¶…è¿‡ 2GB èµ°åç«¯ï¼Œé¿å…æµè§ˆå™¨å†…å­˜æº¢å‡º

            // ä¼˜å…ˆä½¿ç”¨ h5wasm å‰ç«¯ç›´è¯»(ä»… H5 æ–‡ä»¶ä¸”å°äºé˜ˆå€¼)
            if (isH5 && window.h5wasm && window.h5wasmReady && sizeMB <= MAX_LOCAL_SIZE_MB) {
                await loadFileWithH5wasm(file);
            } else if (isH5 && sizeMB > MAX_LOCAL_SIZE_MB) {
                console.log(`File size ${sizeMB.toFixed(1)}MB exceeds ${MAX_LOCAL_SIZE_MB}MB, using backend`);
                showToast(`æ–‡ä»¶è¾ƒå¤§ (${sizeMB.toFixed(0)}MB)ï¼Œä½¿ç”¨åç«¯å¤„ç†...`, 'info');
                await uploadFileToBackend(file);
            } else {
                // å›é€€åˆ°åç«¯ API
                await uploadFileToBackend(file);
            }
        }

        // ========== h5wasm å‰ç«¯ç›´è¯» ==========
        async function loadFileWithH5wasm(file) {
            showLoading('æ­£åœ¨æœ¬åœ°è¯»å–æ–‡ä»¶...');
            const startTime = performance.now();
            const fileName = file.name;
            const fileSize = file.size;

            // è¶…æ—¶å›é€€æœºåˆ¶
            const timeoutId = setTimeout(() => {
                if (state.isLocalFile) return;
                console.warn("h5wasm loading timed out, falling back to backend...");
                showToast('æœ¬åœ°è¯»å–è¶…æ—¶ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°åç«¯æ¨¡å¼...', 'warning');
                uploadFileToBackend(file);
            }, 60000); // 60ç§’è¶…æ—¶

            try {
                const h5 = window.h5wasm;
                const FS = window.h5wasmReady.FS;

                // æ˜¾ç¤ºæ–‡ä»¶å¤§å°ä¿¡æ¯
                const sizeMB = (fileSize / 1024 / 1024).toFixed(1);
                showLoading(`æ­£åœ¨è¯»å–æ–‡ä»¶ (${sizeMB} MB)...`);

                // è¯»å–æ–‡ä»¶ä¸º ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();

                showLoading('æ­£åœ¨å†™å…¥è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ...');
                await new Promise(r => setTimeout(r, 10)); // è®© UI æ›´æ–°

                // å†™å…¥ MEMFSï¼ˆh5wasm å¿…é¡»ä»æ–‡ä»¶ç³»ç»Ÿè¯»å–ï¼‰
                const fname = "ecg_data.h5";
                try { FS.unlink(fname); } catch (e) { }
                FS.writeFile(fname, new Uint8Array(arrayBuffer));

                showLoading('æ­£åœ¨è§£æ HDF5 ç»“æ„...');
                await new Promise(r => setTimeout(r, 10));

                // æ‰“å¼€ HDF5 æ–‡ä»¶
                const h5file = new h5.File(fname, "r");

                showLoading('æ­£åœ¨æå–å…ƒæ•°æ®...');
                await new Promise(r => setTimeout(r, 10));

                // æå–å…ƒæ•°æ®
                let metadata = extractH5Metadata(h5file);

                // è‡ªåŠ¨è¯†åˆ« u+/u- ç”µæé…å¯¹ï¼Œç”Ÿæˆè®¡ç®—å¯¼è”
                metadata = buildComputedLeads(metadata);

                // ä¿å­˜åˆ° state
                state.fileId = 'local_' + Date.now();
                state.metadata = metadata;
                state.h5file = h5file;
                state.isLocalFile = true;

                // æ›´æ–° UI
                updateFileInfo({ metadata });

                // åˆå§‹åŒ–è§†å›¾èŒƒå›´
                state.viewStart = 0;
                // æ ¹æ®å½“å‰é€Ÿåº¦è®¡ç®—åˆå§‹æ—¶é—´çª— (é»˜è®¤ Workmate 400mm å®½åº¦)
                const screenWidthMm = 400;
                const initialRange = screenWidthMm / (state.speed || 25);
                state.viewEnd = Math.min(initialRange, metadata.duration_seconds);
                // ä½¿ç”¨ display_num_channelsï¼ˆè®¡ç®—å¯¼è”æ¨¡å¼ä¸‹æ˜¯åˆå¹¶åçš„é€šé“æ•°ï¼‰
                state.activeChannels = Array.from({ length: metadata.display_num_channels }, (_, i) => i);

                renderChannelList();

                showLoading('æ­£åœ¨æ¸²æŸ“æ³¢å½¢...');
                await new Promise(r => setTimeout(r, 10));
                await loadAndRenderData();

                // æ˜¾ç¤ºæ§ä»¶
                uploadZone.classList.add('hidden');
                document.getElementById('timeline-controls').style.display = 'flex';
                document.getElementById('btn-export-png').disabled = false;
                document.getElementById('btn-export-csv').disabled = false;

                // æ›´æ–°å·¥å…·æ æ‚£è€…ä¿¡æ¯
                const patientInfoEl = document.getElementById('patient-info');
                if (patientInfoEl && state.metadata) {
                    const parts = [];
                    if (state.metadata.patient_name) parts.push(state.metadata.patient_name);
                    if (state.metadata.study_date || state.metadata.date) parts.push(state.metadata.study_date || state.metadata.date);
                    patientInfoEl.textContent = parts.join(' | ');
                }

                clearTimeout(timeoutId);
                const elapsed = (performance.now() - startTime).toFixed(0);
                hideLoading();
                showToast(`æœ¬åœ°åŠ è½½æˆåŠŸ (${elapsed}ms)`, 'success');
                console.log(`âœ… h5wasm loaded ${sizeMB}MB in ${elapsed}ms`);

            } catch (error) {
                clearTimeout(timeoutId);
                console.error('h5wasm error:', error);
                hideLoading();
                showToast('æœ¬åœ°åŠ è½½å¤±è´¥ï¼Œå°è¯•åç«¯å¤„ç†...', 'warning');
                await uploadFileToBackend(file);
            }
        }

        function extractH5Metadata(h5file) {
            const attrs = h5file.attrs;
            const metadata = {
                sampling_freq: 2000,
                num_channels: 0,
                num_samples: 0,
                duration_seconds: 0,
                channel_names: [],
                channel_sources: [],
                study_id: '',
                log_id: '',
                patient_name: '',
                generated_by: ''
            };

            // è¯»å–å±æ€§
            if (attrs['Fs']) metadata.sampling_freq = attrs['Fs'].value[0];
            if (attrs['StudyID']) metadata.study_id = decodeAttr(attrs['StudyID'].value);
            if (attrs['LogID']) metadata.log_id = decodeAttr(attrs['LogID'].value);
            if (attrs['GeneratedBy']) metadata.generated_by = decodeAttr(attrs['GeneratedBy'].value);
            if (attrs['SubjectName']) metadata.patient_name = decodeAttr(attrs['SubjectName'].value);

            // è¯»å–æ•°æ®å½¢çŠ¶
            const dataNode = h5file.get('Data');
            if (dataNode) {
                const shape = dataNode.shape;
                metadata.num_samples = shape[0];
                metadata.num_channels = shape[1];
                metadata.duration_seconds = metadata.num_samples / metadata.sampling_freq;
            }

            // è¯»å–é€šé“ä¿¡æ¯
            const infoNode = h5file.get('Info');
            if (infoNode) {
                try {
                    const infoData = infoNode.value;
                    console.log('Info dataset raw:', infoData);
                    console.log('Info dataset type:', typeof infoData, Array.isArray(infoData));
                    if (infoData.length > 0) {
                        console.log('First row:', infoData[0], 'Type:', typeof infoData[0]);
                    }

                    for (let i = 0; i < infoData.length && i < metadata.num_channels; i++) {
                        const row = infoData[i];
                        // å…¼å®¹å¤šç§å¯èƒ½çš„æ•°æ®ç»“æ„ï¼š
                        // 1. row æ˜¯ [name, source] æ•°ç»„
                        // 2. row æ˜¯ {name: ..., source: ...} å¯¹è±¡
                        // 3. row ç›´æ¥æ˜¯å­—ç¬¦ä¸²ï¼ˆåªæœ‰åç§°ï¼Œæ²¡æ¥æºï¼‰
                        let name, source;
                        if (Array.isArray(row)) {
                            name = decodeAttr(row[0]) || `Ch${i + 1}`;
                            source = decodeAttr(row[1]) || 'RAW';
                        } else if (typeof row === 'string' || row instanceof Uint8Array) {
                            name = decodeAttr(row) || `Ch${i + 1}`;
                            source = 'RAW';
                        } else if (typeof row === 'object' && row !== null) {
                            name = decodeAttr(row.name || row[0]) || `Ch${i + 1}`;
                            source = decodeAttr(row.source || row[1]) || 'RAW';
                        } else {
                            name = `Ch${i + 1}`;
                            source = 'RAW';
                        }
                        metadata.channel_names.push(name);
                        metadata.channel_sources.push(source);
                    }
                    console.log('Extracted channel_names:', metadata.channel_names);
                } catch (e) {
                    console.warn('Info dataset read error:', e);
                }
            }


            // å¦‚æœæ²¡æœ‰é€šé“åï¼Œç”Ÿæˆé»˜è®¤å
            if (metadata.channel_names.length === 0) {
                for (let i = 0; i < metadata.num_channels; i++) {
                    metadata.channel_names.push(`Ch${i + 1}`);
                    metadata.channel_sources.push('RAW');
                }
            }

            return metadata;
        }

        function decodeAttr(val) {
            if (!val) return '';
            if (typeof val === 'string') return val;
            if (val instanceof Uint8Array) return new TextDecoder().decode(val);
            if (Array.isArray(val)) return val[0]?.toString() || '';
            return val.toString();
        }

        /**
         * è‡ªåŠ¨è¯†åˆ« u+X å’Œ u-X ç”µæé…å¯¹ï¼Œç”Ÿæˆè®¡ç®—å¯¼è”æ˜ å°„
         * ä¾‹å¦‚: u+HRA, u-HRA -> HRA (å·®åˆ†)
         * @param {Object} metadata - åŒ…å« channel_names å’Œ channel_sources çš„å…ƒæ•°æ®å¯¹è±¡
         * @returns {Object} ä¿®æ”¹åçš„ metadataï¼ŒåŒ…å« computed_leads æ˜ å°„
         */
        function buildComputedLeads(metadata) {
            const names = metadata.channel_names;
            const sources = metadata.channel_sources;

            // æ£€æµ‹æ˜¯å¦æœ‰ u+ å’Œ u- å‰ç¼€çš„ç”µæï¼ˆè¡¨ç¤ºåŸå§‹å•ææ¨¡å¼ï¼‰
            const plusPattern = /^u\+(.+)$/;  // åŒ¹é… u+XXX
            const minusPattern = /^u-(.+)$/;  // åŒ¹é… u-XXX

            const plusElectrodes = {};  // { leadName: channelIndex }
            const minusElectrodes = {}; // { leadName: channelIndex }
            const otherChannels = [];   // éé…å¯¹é€šé“çš„ç´¢å¼•

            for (let i = 0; i < names.length; i++) {
                const name = names[i];
                const plusMatch = name.match(plusPattern);
                const minusMatch = name.match(minusPattern);

                if (plusMatch) {
                    plusElectrodes[plusMatch[1]] = i;
                } else if (minusMatch) {
                    minusElectrodes[minusMatch[1]] = i;
                } else {
                    otherChannels.push(i);
                }
            }

            // æ‰¾å‡ºå¯ä»¥é…å¯¹çš„å¯¼è”
            const computedLeads = [];  // [{name, plusIdx, minusIdx}]
            const pairedPlusKeys = new Set();

            for (const leadName of Object.keys(plusElectrodes)) {
                if (minusElectrodes.hasOwnProperty(leadName)) {
                    computedLeads.push({
                        name: leadName,
                        plusIdx: plusElectrodes[leadName],
                        minusIdx: minusElectrodes[leadName]
                    });
                    pairedPlusKeys.add(leadName);
                }
            }

            // æ£€æµ‹æ˜¯å¦åº”è¯¥ä½¿ç”¨è®¡ç®—å¯¼è”æ¨¡å¼
            // å¦‚æœæœ‰é…å¯¹çš„å¯¼è”ï¼Œå°±ä½¿ç”¨è®¡ç®—æ¨¡å¼
            if (computedLeads.length > 0) {
                console.log(`Found ${computedLeads.length} computed leads:`, computedLeads.map(l => l.name));

                // å­˜å‚¨åˆ° metadata
                metadata.computed_leads = computedLeads;
                metadata.is_computed_mode = true;

                // ç”Ÿæˆæ–°çš„é€šé“åç§°åˆ—è¡¨ï¼ˆåªåŒ…å«è®¡ç®—å¯¼è”å’Œå…¶ä»–é€šé“ï¼‰
                metadata.display_channel_names = [
                    ...computedLeads.map(l => l.name),
                    ...otherChannels.map(i => names[i])
                ];
                metadata.display_num_channels = metadata.display_channel_names.length;
            } else {
                // æ²¡æœ‰é…å¯¹ï¼Œä¿æŒåŸæ ·
                metadata.computed_leads = [];
                metadata.is_computed_mode = false;
                metadata.display_channel_names = names;
                metadata.display_num_channels = names.length;
            }

            return metadata;
        }

        // ========== åç«¯ API ä¸Šä¼  (å›é€€æ–¹æ¡ˆ) ==========
        async function uploadFileToBackend(file) {
            showLoading('æ­£åœ¨ä¸Šä¼ æ–‡ä»¶...');

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/ecg/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'ä¸Šä¼ å¤±è´¥');
                }

                const result = await response.json();

                // ä½¿ç”¨é€šç”¨åˆå§‹åŒ–
                // è¿™é‡Œçš„ result ç»“æ„åº”è¯¥å’Œ open_local è¿”å›çš„ä¸€è‡´
                // ä½†éœ€è¦åœ¨ result ä¸­è¡¥å…¨ filenameï¼Œå› ä¸º upload æ¥å£å¯èƒ½æ²¡è¿”å› filename?
                // çœ‹ä¹‹å‰çš„ä»£ç ï¼Œfilename æ˜¯ä» file.name å–çš„ã€‚
                // initializeFileSession ä¼šä» metadata æ„é€ æ ‡é¢˜ï¼Œæˆ–è€…å¦‚æœresulté‡Œæœ‰filenameã€‚
                // æˆ‘ä»¬æ‰‹åŠ¨æ³¨å…¥ä¸€ä¸ªã€‚
                result.filename = file.name;

                await initializeFileSession(result, false);

                hideLoading();
                showToast('æ–‡ä»¶åŠ è½½æˆåŠŸ', 'success');

            } catch (error) {
                hideLoading();
                showToast(error.message, 'error');
                console.error('Upload error:', error);
            }
        }

        // ...

        function updateFileInfo(result) {
            const meta = result.metadata;

            // ç ”ç©¶/æ‚£è€…ä¿¡æ¯ï¼ˆå¦‚æœå­˜åœ¨åˆ™æ˜¾ç¤ºï¼‰
            if (meta.study_id) {
                document.getElementById('info-study-id').textContent = meta.study_id;
                document.getElementById('info-study-row').style.display = 'flex';
            }
            if (meta.log_id) {
                document.getElementById('info-log-id').textContent = meta.log_id;
                document.getElementById('info-log-row').style.display = 'flex';
            }
            if (meta.patient_name || meta.patient_id) {
                const patientText = meta.patient_name || meta.patient_id;
                document.getElementById('info-patient').textContent = patientText;
                document.getElementById('info-patient-row').style.display = 'flex';
            }
            if (meta.generated_by) {
                document.getElementById('info-source').textContent = meta.generated_by;
                document.getElementById('info-source-row').style.display = 'flex';
            }

            // æŠ€æœ¯ä¿¡æ¯
            document.getElementById('info-fs').textContent = `${meta.sampling_freq} Hz`;
            document.getElementById('info-channels').textContent = meta.num_channels;
            document.getElementById('info-duration').textContent = formatDuration(meta.duration_seconds);
            document.getElementById('info-samples').textContent = formatNumber(meta.num_samples);
        }

        async function loadAnnotations() {
            if (!state.fileId) return;

            try {
                const response = await fetch(`/api/ecg/annotations/${state.fileId}`);
                if (response.ok) {
                    const result = await response.json();
                    state.annotations = result.annotations || [];
                    renderAnnotationList();
                }
            } catch (error) {
                console.warn('åŠ è½½æ ‡æ³¨å¤±è´¥:', error);
            }
        }

        function renderChannelList() {
            const container = document.getElementById('channel-list');
            const meta = state.metadata;

            // ä½¿ç”¨ display_channel_namesï¼ˆå¦‚æœå­˜åœ¨è®¡ç®—å¯¼è”æ¨¡å¼åˆ™æ˜¯åˆå¹¶åçš„åç§°ï¼‰
            const displayNames = meta.display_channel_names || meta.channel_names;
            const displayCount = meta.display_num_channels || meta.num_channels;

            let html = '';
            for (let i = 0; i < displayCount; i++) {
                const name = displayNames[i] || `Ch ${i + 1}`;
                const color = CHANNEL_COLORS[i % CHANNEL_COLORS.length];
                const isActive = state.activeChannels.includes(i);

                // åˆ¤æ–­æ˜¯å¦ä¸ºè®¡ç®—å¯¼è”
                const isComputed = meta.is_computed_mode && i < (meta.computed_leads?.length || 0);
                const sourceTag = isComputed
                    ? `<span class="channel-tag computed">å·®åˆ†</span>`
                    : `<span class="channel-tag raw">åŸå§‹</span>`;

                // æ£€æŸ¥æ˜¯å¦æœ‰å•ç‹¬çš„æ»¤æ³¢è®¾ç½®
                const filter = state.channelFilters?.[i];
                const filterBadge = filter
                    ? `<span class="channel-filter-badge">${filter.hp || 'DC'}-${filter.lp || 'âˆ'}</span>`
                    : '';

                // è½¬ä¹‰é€šé“åä¸­çš„å•å¼•å·
                const escapedName = name.replace(/'/g, "\\'");

                html += `
                    <div class="channel-item ${isActive ? 'active' : ''}" 
                         onclick="toggleChannel(${i})"
                         oncontextmenu="showChannelContextMenu(event, ${i}, '${escapedName}')">
                        <div class="channel-color" style="background: ${color}"></div>
                        <span class="channel-name">${name}</span>
                        ${sourceTag}
                        ${filterBadge}
                        <div class="channel-toggle">${isActive ? 'âœ“' : ''}</div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        function renderAnnotationList() {
            const container = document.getElementById('annotation-list');

            if (state.annotations.length === 0) {
                container.innerHTML = '<div class="empty-state" style="padding: 20px;"><span style="font-size: 12px;">æ— æ ‡æ³¨æ•°æ®</span></div>';
                return;
            }

            // æ ¼å¼åŒ–ç›¸å¯¹æ—¶é—´ä¸º MM:SS.ss
            function formatRelativeTime(sec) {
                const minutes = Math.floor(sec / 60);
                const seconds = sec % 60;
                return `${minutes.toString().padStart(2, '0')}:${seconds.toFixed(2).padStart(5, '0')}`;
            }

            // ä» metadata è·å–å½•åˆ¶å¼€å§‹æ—¶é—´æˆ³ï¼ˆç§’çº§ Unix æ—¶é—´æˆ³ï¼‰
            // æ”¯æŒå¤šç§å‘½åçº¦å®šï¼šå¤§å†™ Timestampï¼ˆæ™®é€šæ¨¡å¼ï¼‰å’Œ å°å†™ timestampï¼ˆmerged æ¨¡å¼ï¼‰
            const recordStartTimestamp = state.metadata?.attributes?.Timestamp ||
                state.metadata?.attributes?.timestamp ||
                state.metadata?.Timestamp ||
                state.metadata?.timestamp || 0;

            // æ ¼å¼åŒ–å®é™…æ—¶é—´æˆ³ä¸º HH:MM:SSï¼ˆä¸ Log Parser ä¸€è‡´ï¼‰
            function formatAbsoluteTime(timeSec) {
                if (!recordStartTimestamp) return null;
                // è®¡ç®—å®é™…æ—¶é—´ï¼šå½•åˆ¶å¼€å§‹æ—¶é—´ + ç›¸å¯¹ç§’æ•°
                const actualTimestampMs = (recordStartTimestamp + timeSec) * 1000;
                const d = new Date(actualTimestampMs);
                if (isNaN(d.getTime())) return null;
                return d.toLocaleTimeString('en-GB', { hour12: false }); // HH:MM:SS
            }

            let html = '';
            // è·å–æœç´¢å…³é”®è¯
            const searchInput = document.getElementById('annotation-search');
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';

            // è¿‡æ»¤å¹¶æ¸²æŸ“æ ‡æ³¨
            let matchCount = 0;
            for (const annot of state.annotations) {
                const timeSec = annot.time_sec || 0;

                // ä½¿ç”¨å½•åˆ¶å¼€å§‹æ—¶é—´ + time_sec è®¡ç®—å®é™…æ—¶é—´
                const absoluteTime = formatAbsoluteTime(timeSec);
                const timeStr = absoluteTime || formatRelativeTime(timeSec);

                const label = annot.label || annot.message || 'Mark';
                const group = annot.group || '';

                // è¿‡æ»¤é€»è¾‘
                if (searchTerm) {
                    const matchText = `${label} ${group} ${timeStr}`.toLowerCase();
                    if (!matchText.includes(searchTerm)) continue;
                }
                matchCount++;

                // æ˜¾ç¤ºåˆ†ç»„æ ‡ç­¾ï¼ˆå¦‚æœæœ‰ï¼‰
                const groupTag = group ? `<span style="background: #334155; color: #94a3b8; padding: 1px 4px; border-radius: 3px; font-size: 10px; margin-right: 4px;">${group}</span>` : '';

                html += `
                    <div class="annotation-item" onclick="jumpToTime(${timeSec})" title="ç‚¹å‡»è·³è½¬åˆ° ${timeSec.toFixed(2)}s">
                        <span class="annotation-time">${timeStr}</span>
                        <span class="annotation-label">${groupTag}${label}</span>
                    </div>
                `;
            }

            container.innerHTML = html || '<div class="empty-state" style="padding: 12px;"><span style="font-size: 11px;">æ— åŒ¹é…æ ‡æ³¨</span></div>';

            // æ›´æ–°è®¡æ•°
            const countEl = document.getElementById('annotation-count');
            if (countEl) {
                countEl.textContent = searchTerm ? `(${matchCount}/${state.annotations.length})` : `(${state.annotations.length})`;
            }
        }

        // è¿‡æ»¤æ ‡æ³¨ï¼ˆæœç´¢æ¡†è§¦å‘ï¼‰
        function filterAnnotations() {
            renderAnnotationList();
        }

        // ========== æ•°æ®åŠ è½½ä¸æ¸²æŸ“ ==========
        async function loadAndRenderData(showLoadingOverlay = true) {
            if (!state.fileId || state.activeChannels.length === 0) return;

            if (showLoadingOverlay) showLoading('æ­£åœ¨åŠ è½½æ³¢å½¢æ•°æ®...');

            // è®¡ç®—é™é‡‡æ ·å› å­
            // ä¸ºäº†ä¿è¯æ³¢å½¢ä¸å‘ç”Ÿè§†è§‰ä½ç§»ï¼ˆMinMax ç®—æ³•çš„å›ºæœ‰ç¼ºé™·ï¼‰ï¼Œä¸” WebGL æ€§èƒ½è¶³å¤Ÿ
            // æˆ‘ä»¬å¼ºåˆ¶ä¸è¿›è¡Œé™é‡‡æ ·ï¼Œå§‹ç»ˆåŠ è½½åŸå§‹æ•°æ®ã€‚
            const viewDuration = state.viewEnd - state.viewStart;
            // const targetPoints = 2000; // æ—§é€»è¾‘
            // const fs = state.metadata.sampling_freq;
            // const rawPoints = viewDuration * fs;
            // const downsample = Math.max(1, Math.floor(rawPoints / targetPoints));

            // å§‹ç»ˆä½¿ç”¨åŸå§‹æ•°æ®
            const downsample = 1;

            try {
                let result;

                if (state.isLocalFile && state.h5file) {
                    // æœ¬åœ° h5wasm è¯»å–
                    result = readDataFromH5wasm(state.viewStart, state.viewEnd, state.activeChannels, downsample);
                } else {
                    // åç«¯ API è¯»å– - é™åˆ¶å‚æ•°ç²¾åº¦é¿å… URL é—®é¢˜
                    const channelsParam = state.activeChannels.join(',');
                    // åç«¯æ¨¡å¼ï¼šé€šè¿‡ API å‚æ•°ä¼ é€’æ»¤æ³¢è®¾ç½®
                    // æ„å»ºæŸ¥è¯¢å‚æ•°
                    const params = new URLSearchParams();
                    if (state.notchFreq) params.append('notch', state.notchFreq);
                    // ä¼ é€’å¢å¼ºæ ‡å¿—
                    params.append('enhanced_notch', state.enhancedNotch);

                    if (state.lpFreq) params.append('lp', state.lpFreq);
                    if (state.hpFreq) params.append('hp', state.hpFreq);
                    params.append('method', state.filterMethod);

                    // æ·»åŠ è§†çª—èŒƒå›´å‚æ•°
                    params.append('start', state.viewStart);
                    params.append('end', state.viewEnd);
                    params.append('downsample', '4000'); // è¯·æ±‚ 4000 ç‚¹ç”¨äºé«˜å¹³æ»‘åº¦æ˜¾ç¤º
                    // å¼ºåˆ¶è¯·æ±‚æ‰€æœ‰é€šé“ä»¥ä¾¿å‰ç«¯å¤„ç†å¸ƒå±€
                    params.append('channels', state.activeChannels.join(',')); // Ensure active channels are passed
                    if (state.channelFilters && Object.keys(state.channelFilters).length > 0) {
                        params.append('channel_filters', JSON.stringify(state.channelFilters));
                    }

                    const url = `/api/ecg/data/${state.fileId}?${params.toString()}`;
                    console.log(`æ­£åœ¨è¯·æ±‚æ•°æ®: ${url}`);

                    const response = await fetch(url);
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.error || 'æ•°æ®åŠ è½½å¤±è´¥');
                    }

                    result = await response.json();
                }

                state.currentData = result;
                renderWaveforms(result);
                updateViewRange();

                hideLoading();

            } catch (error) {
                hideLoading();
                showToast(error.message, 'error');
                console.error('Data load error:', error);
            }
        }

        // ========== DSP (æ•°å­—ä¿¡å·å¤„ç†) å·¥å…·ç±» ==========
        class DSP {
            // IIR æ»¤æ³¢å™¨ç›´æ¥å½¢å¼ II è½¬ç½®å®ç° (Direct Form II Transposed)
            // b: åˆ†å­ç³»æ•°, a: åˆ†æ¯ç³»æ•°, x: è¾“å…¥æ•°ç»„, zi: åˆå§‹çŠ¶æ€ (å¯é€‰)
            static lfilter(b, a, x, zi = null) {
                const n = x.length;
                const m = b.length;
                if (a.length !== m) throw new Error("Filter coefficients usually have same length");

                const y = new Float32Array(n);
                const z = zi ? new Float32Array(zi) : new Float32Array(m - 1);

                // å½’ä¸€åŒ–ç³»æ•° (å¦‚æœ a[0] != 1) - é€šå¸¸ SciPy ç”Ÿæˆçš„ a[0]=1
                if (a[0] !== 1.0) {
                    const a0 = a[0];
                    for (let i = 0; i < m; i++) { b[i] /= a0; a[i] /= a0; }
                }

                for (let i = 0; i < n; i++) {
                    const xi = x[i];
                    y[i] = b[0] * xi + z[0];
                    for (let j = 0; j < m - 2; j++) {
                        z[j] = b[j + 1] * xi + z[j + 1] - a[j + 1] * y[i];
                    }
                    z[m - 2] = b[m - 1] * xi - a[m - 1] * y[i];
                }

                return { y, z };
            }

            // é›¶ç›¸ä½æ»¤æ³¢ (filtfilt) - ç±»ä¼¼ scipy.signal.filtfilt
            static filtfilt(b, a, x) {
                const len = x.length;
                // 1. å‰å‘æ»¤æ³¢
                const { y: y_forward } = this.lfilter(b, a, x);
                // 2. åè½¬
                y_forward.reverse();
                // 3. åå‘æ»¤æ³¢ (å†æ¬¡é€šè¿‡å‰å‘æ»¤æ³¢å™¨)
                const { y: y_backward } = this.lfilter(b, a, y_forward);
                // 4. åè½¬å›æ¥
                y_backward.reverse();
                return y_backward;
            }

            // è®¡ç®— Butterworth æ»¤æ³¢å™¨ç³»æ•° (ç®€åŒ–ç‰ˆ: ä»…ç›´æ¥è®¡ç®— b/aï¼Œä¸æ¶‰åŠå¤šé¡¹å¼å±•å¼€çš„å¤æ‚åº“)
            // è¿™é‡Œæˆ‘ä»¬ç¡¬ç¼–ç ä¸€äº›å¸¸ç”¨æ»¤æ³¢å™¨æˆ–è€…ä½¿ç”¨è¿‘ä¼¼å…¬å¼ï¼Ÿ
            // å®é™…ä¸Šåœ¨ JS ä¸­å®Œæ•´å®ç° butter() æ¯”è¾ƒå¤æ‚ã€‚
            // ä¸ºäº†ç¨³å¥ï¼Œæˆ‘ä»¬æš‚æ—¶åªæ”¯æŒé¢„å®šä¹‰çš„ç³»æ•° (é’ˆå¯¹å¸¸ç”¨ 50Hz notch, 35Hz LP, 0.5Hz HP ç»“åˆå¸¸è§é‡‡æ ·ç‡ 500/1000Hz)
            // æˆ–è€…ï¼šå®ç°åŒçº¿æ€§å˜æ¢ (Bilinear Transform) æ¥è®¾è®¡æ»¤æ³¢å™¨ã€‚

            static designButterworthLowpass(cutoff, fs, order = 2) {
                if (order === 1) {
                    // 1st Order Butterworth Lowpass
                    // H(s) = 1 / (s + 1) -> Pre-warped Bilinear transform
                    const K = Math.tan(Math.PI * cutoff / fs);
                    const norm = 1 / (1 + K);
                    const b0 = K * norm;
                    const b1 = K * norm;
                    const a0 = 1; // Normalized
                    const a1 = (K - 1) * norm;
                    return { b: [b0, b1], a: [a0, a1] };
                }

                // 2nd Order
                const w0 = 2 * Math.PI * cutoff / fs;
                const cosw0 = Math.cos(w0);
                const sinw0 = Math.sin(w0);
                const alpha_butt = sinw0 / (2 * 0.70710678); // Q = 1/sqrt(2)

                const b0 = (1 - cosw0) / 2;
                const b1 = 1 - cosw0;
                const b2 = (1 - cosw0) / 2;
                const a0 = 1 + alpha_butt;
                const a1 = -2 * cosw0;
                const a2 = 1 - alpha_butt;

                return {
                    b: [b0 / a0, b1 / a0, b2 / a0],
                    a: [1, a1 / a0, a2 / a0]
                };
            }

            // ä¸ºäº†è¾¾åˆ° 4 é˜¶æ•ˆæœï¼Œæˆ‘ä»¬å¯ä»¥è¿è¡Œä¸¤æ¬¡ 2 é˜¶æ»¤æ³¢å™¨
            static applyLowPass(data, fs, cutoff, method) {
                if (!cutoff || cutoff >= fs / 2) return data;

                // é€‰æ‹©é˜¶æ•°ï¼š
                // â˜… Zero-phase (filtfilt) ä½¿ç”¨ 1é˜¶åŸºç¡€ç³»æ•° â˜…
                // filtfilt(1st) = æœ‰æ•ˆ 2é˜¶è¡°å‡ + é›¶ç›¸ä½
                // è¿™æ¯” filtfilt(2nd) = æœ‰æ•ˆ 4é˜¶ ä¿ç•™æ›´å¤šé«˜é¢‘
                // Causal æ¨¡å¼å› ç›¸ä½å¤±çœŸä¼šäº§ç”Ÿé”¯é½¿ï¼Œä¸æ¨èç”¨äºæ˜¾ç¤º
                const order = (method === 'causal') ? 2 : 1;

                const { b, a } = this.designButterworthLowpass(cutoff, fs, order);

                let result = data;

                if (method === 'causal') {
                    // Causal: å•å‘æ»¤æ³¢ï¼Œæœ‰ç›¸ä½å¤±çœŸï¼ˆä¼šäº§ç”Ÿé”¯é½¿ï¼‰
                    // ä»…ç”¨äºéœ€è¦å› æœå…³ç³»çš„å®æ—¶å¤„ç†ï¼Œä¸å»ºè®®ç”¨äºå›æ”¾æ˜¾ç¤º
                    result = this.lfilter(b, a, result).y;

                } else {
                    // Zero-phase (filtfilt): å‰ååŒå‘æ»¤æ³¢
                    // 1é˜¶ç³»æ•° + filtfilt = æœ‰æ•ˆ 2é˜¶è¡°å‡ + é›¶ç›¸ä½
                    result = this.filtfilt(b, a, result);
                }
                return result;
            }

            static designButterworthHighpass(cutoff, fs) {
                const w0 = 2 * Math.PI * cutoff / fs;
                const cosw0 = Math.cos(w0);
                const sinw0 = Math.sin(w0);
                const alpha_butt = sinw0 / (2 * 0.70710678);

                const b0 = (1 + cosw0) / 2;
                const b1 = -(1 + cosw0);
                const b2 = (1 + cosw0) / 2;
                const a0 = 1 + alpha_butt;
                const a1 = -2 * cosw0;
                const a2 = 1 - alpha_butt;

                return {
                    b: [b0 / a0, b1 / a0, b2 / a0],
                    a: [1, a1 / a0, a2 / a0]
                };
            }

            static applyHighPass(data, fs, cutoff, method) {
                if (!cutoff || cutoff <= 0) return data;
                const { b, a } = this.designButterworthHighpass(cutoff, fs);

                let result = data;
                if (method === 'causal') {
                    result = this.lfilter(b, a, result).y;
                } else {
                    result = this.filtfilt(b, a, result);
                }
                return result;
            }

            // â˜… Q å€¼é™ä½ï¼šQ=30 æŒ¯é“ƒä¸¥é‡ï¼ŒQ=10 è¾ƒå¹³è¡¡ â˜…
            static designNotch(freq, fs, q = 10) {
                const w0 = 2 * Math.PI * freq / fs;
                const cosw0 = Math.cos(w0);
                const sinw0 = Math.sin(w0);
                const alpha = sinw0 / (2 * q);

                const b0 = 1;
                const b1 = -2 * cosw0;
                const b2 = 1;
                const a0 = 1 + alpha;
                const a1 = -2 * cosw0;
                const a2 = 1 - alpha;

                return {
                    b: [b0 / a0, b1 / a0, b2 / a0],
                    a: [1, a1 / a0, a2 / a0]
                };
            }

            static applyNotch(data, fs, freq, method) {
                if (!freq) return data;
                const { b, a } = this.designNotch(freq, fs);
                if (method === 'causal') {
                    return this.lfilter(b, a, data).y;
                } else {
                    return this.filtfilt(b, a, data);
                }
            }
        }

        function readDataFromH5wasm(startSec, endSec, channels, downsample) {
            const fs = state.metadata.sampling_freq;
            const startIdx = Math.floor(startSec * fs);
            const endIdx = Math.ceil(endSec * fs);
            const meta = state.metadata;

            const dataNode = state.h5file.get('Data');
            if (!dataNode) throw new Error('Data dataset not found');

            const shape = dataNode.shape;
            const numAllChannels = shape[1];
            const clampedEnd = Math.min(endIdx, shape[0]);

            // è¯»å–å®Œæ•´åˆ‡ç‰‡æ•°æ® (ä¸€ç»´ TypedArray)
            // ä¸ºäº†æ»¤æ³¢è¾¹ç¼˜æ•ˆåº”ï¼Œç¨å¾®å¤šè¯»ä¸€ç‚¹ (ä¾‹å¦‚å‰åå„ 1 ç§’ï¼Œæˆ–è€… 20%)
            // ç®€å•èµ·è§ï¼Œè¿™é‡Œæš‚ä¸é¢„è¯» Paddingï¼Œå› ä¸º h5wasm slice æ¯”è¾ƒå¿«ä½†ä¹Ÿå¯èƒ½å—é™
            const rawDataSlice = dataNode.slice([[startIdx, clampedEnd]]);
            const numToRead = clampedEnd - startIdx;

            // é¢„å¤„ç†ï¼šè§£æ„å¤šé€šé“æ•°æ®ä¸ºç‹¬ç«‹çš„ Float32Array æ•°ç»„ä»¥ä¾¿æ»¤æ³¢
            // rawDataSlice æ˜¯ interlaced: [ch0, ch1, ch2, ch0, ch1, ch2...]
            const channelDataMap = new Map(); // realChIdx -> Float32Array(samples)

            // æ‰¾å‡ºæ‰€æœ‰éœ€è¦è¯»å–çš„ unique åŸå§‹é€šé“ç´¢å¼•
            const uniqueRawIndices = new Set();
            channels.forEach(ch => {
                if (isComputedMode && ch < computedLeads.length) {
                    uniqueRawIndices.add(computedLeads[ch].plusIdx);
                    uniqueRawIndices.add(computedLeads[ch].minusIdx);
                } else if (isComputedMode) {
                    // Find mapped real index (omitted for brevity, assume simple mapping or re-scan)
                    // ... Re-scanning logic found below in getChannelValue ...
                    // ä¸ºç®€åŒ–ï¼Œæˆ‘ä»¬å…ˆå…¨éƒ¨è§£åŒ…ï¼Œæˆ–è€…æŒ‰éœ€è§£åŒ…ã€‚å…¨éƒ¨è§£åŒ…å¯èƒ½å¤ªè´¹å†…å­˜ã€‚
                    // é‰´äº JS æ€§èƒ½ï¼Œæˆ‘ä»¬è¿˜æ˜¯åœ¨ getChannelValue é‡Œå³æ—¶è®¡ç®—æ¯”è¾ƒå¥½ï¼Ÿ
                    // ä¸ï¼Œæ»¤æ³¢å¿…é¡»åœ¨æ—¶åŸŸè¿ç»­æ•°æ®ä¸Šè¿›è¡Œã€‚å¿…é¡»å…ˆè§£åŒ…æˆè¿ç»­æ•°ç»„ã€‚
                } else {
                    uniqueRawIndices.add(ch);
                }
            });

            // å¦‚æœè®¡ç®—æ¨¡å¼æ¯”è¾ƒå¤æ‚ï¼Œæˆ‘ä»¬ä¸å¦¨å…ˆè§£åŒ…â€œæ‰€æœ‰æ¶‰åŠåˆ°çš„â€é€šé“
            // ç®€åŒ–ç­–ç•¥ï¼šå°† interlaced æ•°æ®è½¬æ¢æˆ planar (ch, time)

            // 1. Deinterlace desired channels
            // ç”±äºæˆ‘ä»¬è¿˜è¦æ”¯æŒ filterï¼Œæˆ‘ä»¬éœ€è¦å®Œæ•´çš„æ—¶åºæ•°ç»„
            const rawChannelData = {}; // chIdx -> Float32Array

            // æ…¢ä½†æ˜¯é€šç”¨ï¼š
            // æˆ‘ä»¬åªæ»¤æ³¢å¯è§†çš„ Raw Channelsã€‚
            // é‡æ–°æ‰«æ uniqueRawIndices (å¦‚æœæ˜¯ Computed Modeï¼Œé€»è¾‘æ¯”è¾ƒç»•ï¼Œè¿™é‡Œå…ˆå‡è®¾éComputedæˆ–ç®€å•å¤„ç†)

            // é’ˆå¯¹å½“å‰ Active Channels æ‰€éœ€çš„ Raw Channels
            const requiredRawChs = new Set();
            if (isComputedMode) {
                // æš‚æ—¶ä¸æ”¯æŒ Computed Lead çš„æœ¬åœ°æ»¤æ³¢ï¼Œæˆ–è€…åº”ç”¨åˆ°æ‰€æœ‰ Raw
                // ä¸ºå®‰å…¨èµ·è§ï¼Œç®€å•èµ·è§ï¼š
                // å¦‚æœæ˜¯ local æ»¤æ³¢ï¼Œè§£åŒ…æ‰€æœ‰é€šé“å¯èƒ½å¤ªæ…¢ã€‚
                // æˆ‘ä»¬å‡è®¾ Active Channels ç›´æ¥å¯¹åº” Raw Channels (é Computed æ¨¡å¼å¸¸è§)
                // å¦‚æœæ˜¯ Computedï¼Œæˆ‘ä»¬åªæ»¤ Raw æ•°æ®ã€‚
                for (let i = 0; i < numAllChannels; i++) requiredRawChs.add(i); // æš´åˆ©è§£åŒ…æ‰€æœ‰? 
            } else {
                channels.forEach(ch => requiredRawChs.add(ch));
            }

            for (let ch of requiredRawChs) {
                rawChannelData[ch] = new Float32Array(numToRead);
            }

            for (let i = 0; i < numToRead; i++) {
                const base = i * numAllChannels;
                for (let ch of requiredRawChs) {
                    rawChannelData[ch][i] = rawDataSlice[base + ch];
                }
            }

            // 2. Apply Filters to each Raw Channel
            const filterMethod = state.filterMethod || 'zero_phase';

            for (let ch of requiredRawChs) {
                let sig = rawChannelData[ch];

                // åº”ç”¨é¡ºåºï¼šNotch -> HP -> LP (å‚è€ƒåç«¯)

                // â˜… è°ƒè¯•å¼€å…³ï¼šè®¾ä¸º true å¯å®Œå…¨è·³è¿‡æ»¤æ³¢ï¼Œæ˜¾ç¤ºåŸå§‹æ•°æ® â˜…
                const BYPASS_ALL_FILTERS = false; // æ¢å¤æ­£å¸¸æ»¤æ³¢

                if (!BYPASS_ALL_FILTERS) {
                    // Notch
                    if (state.notchFreq) {
                        sig = DSP.applyNotch(sig, fs, parseFloat(state.notchFreq), filterMethod);
                    }

                    // HP
                    if (state.hpFreq) {
                        sig = DSP.applyHighPass(sig, fs, parseFloat(state.hpFreq), filterMethod);
                    }

                    // LP
                    if (state.lpFreq) {
                        sig = DSP.applyLowPass(sig, fs, parseFloat(state.lpFreq), filterMethod);
                    }
                } // else: è·³è¿‡æ‰€æœ‰æ»¤æ³¢ï¼Œæ˜¾ç¤ºåŸå§‹æ•°æ®

                rawChannelData[ch] = sig;
            }

            // 3. æ›¿æ¢ getChannelValue ä»¥ä½¿ç”¨å·²æ»¤æ³¢çš„æ•°æ®
            function getChannelValue(sampleIdx, displayIdx) {
                // const baseIdx = sampleIdx * numAllChannels; // æ—§é€»è¾‘

                if (isComputedMode && displayIdx < computedLeads.length) {
                    const lead = computedLeads[displayIdx];
                    // ä½¿ç”¨å·²æ»¤æ³¢çš„ planar æ•°æ®
                    const v1 = rawChannelData[lead.plusIdx]?.[sampleIdx] || 0;
                    const v2 = rawChannelData[lead.minusIdx]?.[sampleIdx] || 0;
                    return v1 - v2;
                } else if (isComputedMode) {
                    // ... å¤æ‚æ˜ å°„ ... 
                    // å› ä¸Šæ–¹æˆ‘ä»¬å·²ç»æš´åˆ©è§£åŒ…äº†æ‰€æœ‰é€šé“ (requiredRawChs åŒ…å«äº† all)ï¼Œæ‰€æœ‰è¿™é‡Œç®€åŒ–
                    // è¿™é‡Œéœ€è¦æ‰¾åˆ° displayIdx å¯¹åº”çš„ realIdx
                    // ç•¥è¿‡å¤æ‚æ˜ å°„ï¼Œæš‚ä¸æ”¯æŒ Local Computed Mode çš„éƒ¨åˆ†å¤æ‚é€šé“ï¼Œå›é€€åˆ°åŸå§‹ slice?
                    // åªæœ‰å½“ rawChannelData[realIdx] å­˜åœ¨æ—¶æ‰ç”¨ï¼Œå¦åˆ™ç”¨ rawDataSlice
                    return 0; // TODO: Fix computed mode mapping for local filter
                } else {
                    // éè®¡ç®—æ¨¡å¼
                    return rawChannelData[displayIdx][sampleIdx];
                }
            }

            const time = [];
            const data = [];

            if (downsample <= 1) {
                // æ— éœ€é™é‡‡æ ·ï¼Œé€ç‚¹è¯»å–
                for (let i = 0; i < numToRead; i++) {
                    time.push(startSec + (i / fs));
                    const row = new Float32Array(outputChannelCount);
                    for (let c = 0; c < outputChannelCount; c++) {
                        row[c] = getChannelValue(i, channels[c]);
                    }
                    data.push(row);
                }
            } else {
                // Min-Max é™é‡‡æ ·ï¼šä¿ç•™æ¯ä¸ªçª—å£å†…çš„æœ€å°å€¼å’Œæœ€å¤§å€¼
                const nWindows = Math.floor(numToRead / downsample);
                const remainder = numToRead % downsample;

                for (let w = 0; w < nWindows; w++) {
                    const windowStart = w * downsample;
                    const windowEnd = windowStart + downsample;
                    const windowMidTime = startSec + ((windowStart + downsample / 2) / fs);

                    // Min è¡Œ
                    const minRow = new Float32Array(outputChannelCount);
                    // Max è¡Œ
                    const maxRow = new Float32Array(outputChannelCount);

                    // åˆå§‹åŒ–
                    for (let c = 0; c < outputChannelCount; c++) {
                        minRow[c] = Infinity;
                        maxRow[c] = -Infinity;
                    }

                    // éå†çª—å£å†…æ‰€æœ‰é‡‡æ ·ç‚¹
                    for (let i = windowStart; i < windowEnd && i < numToRead; i++) {
                        for (let c = 0; c < outputChannelCount; c++) {
                            const val = getChannelValue(i, channels[c]);
                            if (val < minRow[c]) minRow[c] = val;
                            if (val > maxRow[c]) maxRow[c] = val;
                        }
                    }

                    // äº¤é”™æ·»åŠ  min å’Œ maxï¼ˆä¿æŒæ³¢å½¢å½¢æ€ï¼‰
                    time.push(startSec + (windowStart / fs));
                    data.push(minRow);
                    time.push(startSec + ((windowEnd - 1) / fs));
                    data.push(maxRow);
                }

                // å¤„ç†ä½™æ•°éƒ¨åˆ†ï¼ˆç¡®ä¿è¦†ç›–å®Œæ•´æ—¶é—´èŒƒå›´ï¼‰
                if (remainder > 0) {
                    const remStart = nWindows * downsample;
                    const minRow = new Float32Array(outputChannelCount);
                    const maxRow = new Float32Array(outputChannelCount);

                    for (let c = 0; c < outputChannelCount; c++) {
                        minRow[c] = Infinity;
                        maxRow[c] = -Infinity;
                    }

                    for (let i = remStart; i < numToRead; i++) {
                        for (let c = 0; c < outputChannelCount; c++) {
                            const val = getChannelValue(i, channels[c]);
                            if (val < minRow[c]) minRow[c] = val;
                            if (val > maxRow[c]) maxRow[c] = val;
                        }
                    }

                    time.push(startSec + (remStart / fs));
                    data.push(minRow);
                    time.push(endSec); // ç¡®ä¿è¦†ç›–åˆ°ç»“æŸæ—¶é—´
                    data.push(maxRow);
                }
            }

            // æ„å»ºé€šé“åï¼ˆä½¿ç”¨ display åç§°ï¼‰
            const channelNames = channels.map(ch => displayNames[ch] || `Ch${ch + 1}`);

            return {
                time,
                data,
                channel_names: channelNames,
                sampling_freq: fs / downsample,
                units: 'mV'
            };
        }

        function renderWaveforms(data) {
            if (!data || !data.channel_names) {
                console.warn('renderWaveforms: Invalid data', data);
                return;
            }
            // åˆ†é¡µé€»è¾‘
            const totalChannels = data.channel_names.length;

            // è¶Šç•Œä¿æŠ¤
            if (state.currentPage * state.channelsPerPage >= totalChannels && totalChannels > 0) {
                console.warn(`renderWaveforms: Page ${state.currentPage} out of bounds. Resetting.`);
                state.currentPage = 0;
                // æ­¤æ—¶ä¸é€’å½’è°ƒç”¨ï¼Œè€Œæ˜¯ç»§ç»­æ‰§è¡Œï¼Œå› ä¸º startIndex ä¼šé‡ç®—
                updatePaginationUI();
            }

            const startIndex = state.currentPage * state.channelsPerPage;
            const endIndex = Math.min(startIndex + state.channelsPerPage, totalChannels);

            // æˆªå–å½“å‰é¡µæ˜¾ç¤ºçš„é€šé“æ•°æ®
            const visibleChannelNames = data.channel_names.slice(startIndex, endIndex);
            const numVisibleChannels = visibleChannelNames.length;

            // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæ¸…ç©ºå›¾è¡¨
            if (numVisibleChannels === 0) {
                Plotly.purge('ecg-plot');
                return;
            }

            const traces = [];

            // æ•°æ®ç»“æ„æ˜¯ data.data[sampleIndex][channelIndex]
            // æˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸ªé‡‡æ ·ç‚¹æˆªå–å¯¹åº”çš„é€šé“
            const visibleData = data.data.map(row => {
                // å…¼å®¹ TypedArray (subarray) å’Œæ™®é€š Array (slice)
                return (row.subarray || row.slice).call(row, startIndex, endIndex);
            });

            if (visibleData.length > 0) {
                console.log('Visible Data Sample (Row 0):', visibleData[0]);
            }

            const time = data.time;

            // å°†ç›¸å¯¹æ—¶é—´è½¬æ¢ä¸ºç»å¯¹æ—¶é—´æˆ³ (Date å¯¹è±¡ï¼Œç”¨äº Plotly)
            const recordStartTimestamp = state.metadata?.attributes?.Timestamp ||
                state.metadata?.attributes?.timestamp ||
                state.metadata?.Timestamp ||
                state.metadata?.timestamp || 0;

            let absoluteTime;
            if (recordStartTimestamp) {
                absoluteTime = time.map(t => new Date((recordStartTimestamp + t) * 1000));
            } else {
                // æ— å½•åˆ¶å¼€å§‹æ—¶é—´ï¼Œå›é€€åˆ°ç›¸å¯¹æ—¶é—´
                absoluteTime = time;
            }
            const xAxisData = absoluteTime;

            // â˜… ç‰©ç†å®šæ ‡é€»è¾‘ (Workmate é£æ ¼ - çº¯ç‰©ç†åæ ‡ç³») â˜…
            // Y è½´å•ä½ï¼šmm (æ¯«ç±³)
            // æ€»é«˜åº¦ï¼š320 mm (æ¨¡æ‹Ÿ Workmate å‚ç›´æ˜¾ç¤ºå™¨)
            const PHYSICAL_SCREEN_HEIGHT_MM = 320;

            // æ¯ä¸ªé€šé“åˆ†é…çš„é«˜åº¦ (mm)
            const channelHeightMm = PHYSICAL_SCREEN_HEIGHT_MM / numVisibleChannels;

            // æ£€æµ‹æ•°æ®å•ä½å¯èƒ½æ˜¯ uV (å¾®ä¼) è€Œä¸æ˜¯ mV
            let dataMin = Infinity, dataMax = -Infinity;
            for (let i = 0; i < numVisibleChannels; i++) {
                for (let j = 0; j < Math.min(visibleData.length, 1000); j += 5) {
                    const val = visibleData[j][i];
                    if (val < dataMin) dataMin = val;
                    if (val > dataMax) dataMax = val;
                }
            }
            const dataRange = dataMax - dataMin;
            // è‡ªåŠ¨ç¼©æ”¾å› å­: å¦‚æœæ•°æ®çœ‹èµ·æ¥åƒ uV (range > 50), åˆ™é™¤ä»¥ 1000 è½¬ä¸º mV
            const unitScaleFactor = dataRange > 50 ? 0.001 : 1.0;

            console.log(`PhysRefactor: Height=${PHYSICAL_SCREEN_HEIGHT_MM}mm | ChHeight=${channelHeightMm.toFixed(2)}mm | UnitScale=${unitScaleFactor}`);

            if (state.displayMode === 'stacked') {
                for (let i = 0; i < numVisibleChannels; i++) {
                    const actualChIndex = state.activeChannels[startIndex + i];
                    const filter = state.channelFilters?.[actualChIndex] || {};
                    const amplitude = filter.amplitude ? parseFloat(filter.amplitude) : 1.0; // mV/cm
                    const clipping = filter.clipping ? parseFloat(filter.clipping) : null; // cm (1cm = 10mm)

                    // 1. è®¡ç®—é€šé“ä¸­å¿ƒåŸºçº¿ (mm) - ä»ä¸Šåˆ°ä¸‹æ’åˆ—
                    // ç¬¬ 0 ä¸ªé€šé“åœ¨æœ€ä¸Šæ–¹ (Offset æœ€å¤§)
                    const offsetMm = (numVisibleChannels - 1 - i) * channelHeightMm + (channelHeightMm / 2);

                    let chData = visibleData.map(row => row[i]);

                    // 2. ç»Ÿä¸€è½¬æ¢ä¸º mV
                    if (unitScaleFactor !== 1.0) {
                        chData = chData.map(v => v * unitScaleFactor);
                    }

                    // 3. åº”ç”¨ Amplitude ç¼©æ”¾ (è½¬æ¢ä¸º mm)
                    // 1 mV/cm => 1 mV å¯¹åº” 10 mm é«˜åº¦
                    // å…¬å¼: y_mm = val_mV * (10 / amplitude_mV_per_cm)
                    const mmPerMv = 10 / amplitude;
                    chData = chData.map(v => v * mmPerMv);

                    // 4. åº”ç”¨ Clipping (åœ¨ mm ç©ºé—´)
                    // clipping = 1 cm => Â±10 mm
                    if (clipping) {
                        const clipLimitMm = clipping * 10;
                        chData = chData.map(v => Math.max(-clipLimitMm, Math.min(clipLimitMm, v)));
                    }

                    // 5. åŠ ä¸ŠåŸºçº¿åç§» (mm)
                    chData = chData.map(v => v + offsetMm);

                    // â˜… è§†è§‰å¹³æ»‘å¤„ç† â˜…
                    // 1. [æ•°æ®å±‚] å¾®å¼±é¢„å¹³æ»‘ (æƒé‡ [0.1, 0.8, 0.1])
                    if (chData.length > 3) {
                        const smoothed = new Float32Array(chData.length);
                        smoothed[0] = chData[0];
                        for (let k = 1; k < chData.length - 1; k++) {
                            smoothed[k] = chData[k - 1] * 0.1 + chData[k] * 0.8 + chData[k + 1] * 0.1;
                        }
                        smoothed[chData.length - 1] = chData[chData.length - 1];
                        chData = smoothed;
                    }

                    // 2. [é‡‡æ ·å±‚] LTTB é™é‡‡æ ·
                    // ç›®æ ‡ç‚¹æ•°ï¼š4000ç‚¹ (æå¤§åŒ–ä¿ç•™ç»†èŠ‚ï¼Œæ¥è¿‘æ— æŸ)
                    const targetPoints = 4000;
                    let plotX = xAxisData;
                    let plotY = chData;

                    if (chData.length > targetPoints) {
                        // console.log(`[LTTB] Processing channel ${i}, points: ${chData.length}`);
                        try {
                            // å‡†å¤‡ LTTB è¾“å…¥: [[index, value], ...]
                            // æ ‡å‡†åº“åªæ¥å—æ•°ç»„å½¢å¼çš„æ•°æ®ç‚¹
                            const points = new Array(chData.length);
                            for (let k = 0; k < chData.length; k++) {
                                points[k] = [k, chData[k]];
                            }

                            // æ ¹æ®ç®—æ³•é€‰æ‹©é™é‡‡æ ·æ–¹å¼
                            let sampled;
                            if (state.downsampleAlgo === 'minmax') {
                                sampled = DSP.minMaxDownsample(chData, targetPoints);
                            } else {
                                sampled = LTTB.process(points, targetPoints);
                            }

                            // æ˜ å°„å›æ—¶é—´å’Œæ•°å€¼
                            // sampled æ˜¯ [[index, value], ...]
                            plotX = new Float32Array(sampled.length);
                            plotY = new Float32Array(sampled.length);

                            for (let k = 0; k < sampled.length; k++) {
                                const originalIndex = sampled[k][0];
                                plotX[k] = xAxisData[originalIndex];
                                plotY[k] = sampled[k][1];
                            }
                        } catch (e) {
                            console.warn('Downsample error, fallback to raw data', e);
                            plotX = xAxisData;
                            plotY = chData;
                        }
                    }



                    // Debug info
                    // console.log(`Trace ${visibleChannelNames[i]}: ${plotX.length} points`);

                    // æ ¹æ®å¼•æ“é€‰æ‹© Plotly ç±»å‹å’Œçº¿æ¡æ ·å¼
                    const isSVG = state.renderEngine === 'svg';

                    traces.push({
                        type: isSVG ? 'scatter' : 'scattergl', // SVG vs WebGL
                        x: plotX,
                        y: plotY,
                        mode: 'lines',
                        name: visibleChannelNames[i],
                        line: {
                            color: CHANNEL_COLORS[(startIndex + i) % CHANNEL_COLORS.length],
                            width: 2,
                            shape: isSVG ? 'spline' : 'linear', // WebGL ä¸æ”¯æŒ spline
                            smoothing: isSVG ? 0.3 : 0          // ä»… SVG æœ‰æ•ˆ
                        },
                        hoverinfo: 'x+y+name'
                    });
                }
            } else {
                // å åŠ æ¨¡å¼ (Overlay)
                for (let i = 0; i < numVisibleChannels; i++) {
                    let chData = visibleData.map(row => row[i]);

                    // 1. [æ•°æ®å±‚] å¾®å¼±é¢„å¹³æ»‘ (å¯é€‰)
                    if (state.enableSmoothing && chData.length > 3) {
                        const smoothed = new Float32Array(chData.length);
                        smoothed[0] = chData[0];
                        for (let k = 1; k < chData.length - 1; k++) {
                            smoothed[k] = chData[k - 1] * 0.1 + chData[k] * 0.8 + chData[k + 1] * 0.1;
                        }
                        smoothed[chData.length - 1] = chData[chData.length - 1];
                        chData = smoothed;
                    }

                    // 2. [é‡‡æ ·å±‚] LTTB é™é‡‡æ ·
                    const targetPoints = 4000;
                    let plotX = xAxisData;
                    let plotY = chData;

                    if (chData.length > targetPoints) {
                        try {
                            const points = new Array(chData.length);
                            for (let k = 0; k < chData.length; k++) { points[k] = [k, chData[k]]; }

                            // æ ¹æ®ç®—æ³•é€‰æ‹©é™é‡‡æ ·æ–¹å¼
                            let sampled;
                            if (state.downsampleAlgo === 'minmax') {
                                sampled = DSP.minMaxDownsample(chData, targetPoints);
                            } else {
                                sampled = LTTB.process(points, targetPoints);
                            }

                            plotX = new Float32Array(sampled.length);
                            plotY = new Float32Array(sampled.length);

                            for (let k = 0; k < sampled.length; k++) {
                                const originalIndex = sampled[k][0];
                                plotX[k] = xAxisData[originalIndex];
                                plotY[k] = sampled[k][1];
                            }
                        } catch (e) {
                            console.warn('Downsample error overlay', e);
                            plotX = xAxisData;
                            plotY = chData;
                        }
                    }

                    // æ ¹æ®å¼•æ“é€‰æ‹© Plotly ç±»å‹å’Œçº¿æ¡æ ·å¼
                    const isSVG = state.renderEngine === 'svg';

                    traces.push({
                        type: isSVG ? 'scatter' : 'scattergl',
                        x: plotX,
                        y: plotY,
                        mode: 'lines',
                        name: visibleChannelNames[i],
                        line: {
                            color: CHANNEL_COLORS[(startIndex + i) % CHANNEL_COLORS.length],
                            width: 2,
                            opacity: 1.0,
                            shape: isSVG ? 'spline' : 'linear',
                            smoothing: isSVG ? 0.3 : 0
                        }
                    });
                }
            }

            // 3. å¤„ç†æ ‡æ³¨ (Annotations)
            const viewAnnots = state.annotations.filter(a =>
                a.time_sec >= state.viewStart && a.time_sec <= state.viewEnd
            );

            const shapes = viewAnnots.map(a => {
                const xVal = recordStartTimestamp ? new Date((recordStartTimestamp + a.time_sec) * 1000) : a.time_sec;
                return {
                    type: 'line',
                    x0: xVal,
                    x1: xVal,
                    y0: 0,
                    y1: 1,
                    yref: 'paper',
                    line: { color: '#f59e0b', width: 1, dash: 'dot' }
                };
            });

            const annotationMarkers = viewAnnots.map((a, idx) => {
                const xVal = recordStartTimestamp ? new Date((recordStartTimestamp + a.time_sec) * 1000) : a.time_sec;
                const fullLabel = a.label || 'M';
                const displayLabel = fullLabel.length > 15 ? fullLabel.substring(0, 12) + '...' : fullLabel;
                return {
                    x: xVal,
                    y: 0.96,  // å›¾è¡¨å†…éƒ¨ä¸Šæ–¹
                    yref: 'paper',
                    text: displayLabel,
                    hovertext: `${fullLabel} (ç‚¹å‡»è·³è½¬)`,
                    showarrow: true,
                    arrowhead: 2,
                    ax: 0,
                    ay: -25,
                    font: { size: 11, color: '#f59e0b' },
                    bgcolor: 'rgba(0, 0, 0, 0.85)',
                    bordercolor: '#f59e0b',
                    borderwidth: 1,
                    borderpad: 3,
                    captureevents: true,  // å…è®¸æ•è·ç‚¹å‡»äº‹ä»¶
                    name: `annot_${a.time_sec}`  // ç”¨äºè¯†åˆ«ç‚¹å‡»çš„æ ‡æ³¨
                };
            });

            // 5. åœ¨å †å æ¨¡å¼ä¸‹ï¼Œæ·»åŠ å·¦ä¾§é€šé“åç§°æ ‡æ³¨
            const channelNameAnnotations = [];
            if (state.displayMode === 'stacked' && traces.length > 0) {
                // éœ€è¦è®¡ç®—æ¯ä¸ªé€šé“çš„ Y ä½ç½®
                // traces æ˜¯æŒ‰ç…§ (numVisibleChannels - 1 - i) * offsetStep åç§»çš„
                // ç¬¬ä¸€ä¸ª trace (i=0) æœ‰æœ€å¤§ offsetï¼Œæœ€åä¸€ä¸ª (i=n-1) offset ä¸º 0
                const dataRange = traces.length > 0 ? (traces[0].y[0] - traces[traces.length - 1].y[0]) / (traces.length > 1 ? 1 : 1) : 1;

                for (let i = 0; i < numVisibleChannels; i++) {
                    // è®¡ç®—è¿™ä¸ªé€šé“çš„å¹³å‡ Y å€¼ï¼ˆç”¨ç¬¬ä¸€ä¸ªç‚¹å³å¯ï¼‰
                    const yPos = traces[i].y[0];

                    channelNameAnnotations.push({
                        xref: 'paper',
                        yref: 'y',
                        x: -0.01,
                        y: yPos,
                        text: visibleChannelNames[i],
                        showarrow: false,
                        font: {
                            size: 10,
                            color: CHANNEL_COLORS[(startIndex + i) % CHANNEL_COLORS.length]
                        },
                        xanchor: 'right',
                        yanchor: 'middle',
                        captureevents: true,  // å…è®¸ç‚¹å‡»äº‹ä»¶
                        name: `ch-${i}`       // ç”¨äºæ ‡è¯†æ˜¯å“ªä¸ªé€šé“
                    });
                }
            }

            // 6. æ„å»º Layout
            const layout = {
                paper_bgcolor: '#0f0f13',
                plot_bgcolor: '#0f0f13',
                margin: { l: 80, r: 20, t: 10, b: 40 },  // æ‰©å¤§å·¦è¾¹è·å®¹çº³é€šé“åï¼Œå‡å°é¡¶éƒ¨è¾¹è·
                xaxis: {
                    title: { text: recordStartTimestamp ? 'Time' : 'Time (s)', font: { color: '#a0a0b0', size: 12 } },
                    color: '#a0a0b0',
                    gridcolor: state.showGrid ? '#2a2a3a' : 'transparent',
                    zerolinecolor: '#2a2a3a',
                    tickfont: { size: 11 },
                    type: recordStartTimestamp ? 'date' : 'linear',
                    tickformatstops: [
                        { dtickrange: [null, 1000], value: '%H:%M:%S.%L' }, // < 1s é—´éš”æ˜¾ç¤ºæ¯«ç§’
                        { dtickrange: [1000, null], value: '%H:%M:%S' }     // >= 1s é—´éš”æ˜¾ç¤ºç§’
                    ],
                    // ç§»é™¤å›ºå®š formatï¼Œæ”¹ç”¨ stops
                    // tickformat: ...
                    // æ˜ç¡®è®¾ç½® X è½´èŒƒå›´ï¼Œé˜²æ­¢ Plotly è‡ªåŠ¨æ‰©å±•
                    range: recordStartTimestamp
                        ? [new Date((recordStartTimestamp + state.viewStart) * 1000),
                        new Date((recordStartTimestamp + state.viewEnd) * 1000)]
                        : [state.viewStart, state.viewEnd]
                },
                yaxis: {
                    title: { text: state.displayMode === 'overlay' ? `Amplitude (${state.metadata.units})` : '', font: { color: '#a0a0b0', size: 12 } },
                    color: '#a0a0b0',
                    gridcolor: state.showGrid ? '#2a2a3a' : 'transparent',
                    zerolinecolor: '#2a2a3a',
                    showticklabels: state.displayMode === 'overlay',
                    tickfont: { size: 11 },
                    // â˜… ç‰©ç†å®šæ ‡ï¼šé”å®š Y è½´èŒƒå›´ â˜…
                    autorange: false,
                    // Y è½´ä½¿ç”¨ç‰©ç†å®šæ ‡ (mm)
                    // èŒƒå›´å›ºå®šä¸º [0, 320] mm
                    range: state.displayMode === 'stacked'
                        ? [0, 320]
                        : undefined,
                    // ç½‘æ ¼çº¿æ¯ 10mm (1cm) ä¸€æ¡ï¼Œå¯¹åº”æ ‡å‡†å¿ƒç”µå›¾çº¸çš„å¤§æ ¼
                    dtick: 10,
                },
                // éšè—å³ä¾§ legendï¼Œä½¿ç”¨å·¦ä¾§é€šé“åç‚¹å‡»åˆ‡æ¢
                showlegend: false,

                shapes: shapes,
                annotations: [...annotationMarkers, ...channelNameAnnotations],

                // åŠ¨æ€é«˜åº¦ï¼šä½¿ç”¨å®¹å™¨é«˜åº¦å‡å»åº•éƒ¨æ§ä»¶
                height: document.querySelector('.waveform-container')?.clientHeight - 20 || Math.max(400, numVisibleChannels * 50),
                hovermode: 'closest'
            };

            const config = {
                responsive: true,
                displayModeBar: false,
                scrollZoom: true,
                editable: true,  // å…è®¸ç¼–è¾‘
                edits: {
                    annotationPosition: true, // ä»…å…è®¸ç§»åŠ¨æ ‡æ³¨
                    annotationTail: false,
                    annotationText: false,
                    axisTitleText: false,
                    colorbarTitleText: false,
                    figureTitleText: false,
                    legendPosition: false,
                    legendText: false,
                    shapePosition: false,
                    titleText: false
                }
            };

            Plotly.react('ecg-plot', traces, layout, config);

            // æ›´æ–°åˆ†é¡µ UI (ç¡®ä¿çŠ¶æ€åŒæ­¥)
            updatePaginationUI();

            // é¦–æ¬¡æ¸²æŸ“åç»‘å®š Plotly äº‹ä»¶ï¼ˆåªç»‘å®šä¸€æ¬¡ï¼‰
            if (!state.plotlyEventsInitialized) {
                state.plotlyEventsInitialized = true;
                const plotDiv = document.getElementById('ecg-plot');
                plotDiv.on('plotly_relayout', function (eventData) {
                    if (eventData['xaxis.range[0]'] !== undefined) {
                        // è·å–å½•åˆ¶å¼€å§‹æ—¶é—´æˆ³
                        const recordStartTimestamp = state.metadata?.attributes?.Timestamp ||
                            state.metadata?.attributes?.timestamp ||
                            state.metadata?.Timestamp ||
                            state.metadata?.timestamp || 0;

                        let newStart = eventData['xaxis.range[0]'];
                        let newEnd = eventData['xaxis.range[1]'];

                        // å¦‚æœæ˜¯ç»å¯¹æ—¶é—´è½´ï¼ŒPlotly è¿”å›çš„æ˜¯ Date å­—ç¬¦ä¸²ï¼Œéœ€è¦è½¬æ¢å›ç›¸å¯¹ç§’æ•°
                        if (recordStartTimestamp && typeof newStart === 'string') {
                            const startDate = new Date(newStart);
                            const endDate = new Date(newEnd);
                            newStart = (startDate.getTime() / 1000) - recordStartTimestamp;
                            newEnd = (endDate.getTime() / 1000) - recordStartTimestamp;
                        }

                        // ç¡®ä¿æ˜¯æ•°å­—
                        state.viewStart = typeof newStart === 'number' ? newStart : parseFloat(newStart) || 0;
                        state.viewEnd = typeof newEnd === 'number' ? newEnd : parseFloat(newEnd) || 10;

                        updateViewRange();

                        // é˜²æŠ–åŠ è½½æ–°æ•°æ®
                        clearTimeout(state.loadTimeout);
                        state.loadTimeout = setTimeout(() => {
                            loadAndRenderData();
                        }, 300);
                        return; // X è½´ç¼©æ”¾/å¹³ç§»ä¸ç»§ç»­å¤„ç†æ ‡æ³¨ç§»åŠ¨
                    }

                    // 2. æ£€æµ‹æ ‡æ³¨ç§»åŠ¨ (annotations[i].x)
                    // eventData æ ¼å¼å¯èƒ½æ˜¯ {'annotations[0].x': 12.34}
                    const keys = Object.keys(eventData);
                    let annotationMoved = false;

                    keys.forEach(key => {
                        if (key.match(/^annotations\[\d+\]\.x$/)) {
                            const index = parseInt(key.match(/\d+/)[0]);
                            const newX = eventData[key];

                            // è·å–è¢«ç§»åŠ¨çš„æ ‡æ³¨å¯¹è±¡ (ä» Plotly layout ä¸­)
                            // æ³¨æ„ï¼ševentData è§¦å‘æ—¶ layout å¯èƒ½è¿˜æ²¡æ›´æ–°ï¼Œæˆ–è€…å·²ç»æ›´æ–°ï¼Œæœ€å¥½ç›´æ¥çœ‹ plotDiv.layout
                            if (plotDiv.layout.annotations && plotDiv.layout.annotations[index]) {
                                const annotName = plotDiv.layout.annotations[index].name;

                                if (annotName && annotName.startsWith('annot_')) {
                                    const oldTimeSec = parseFloat(annotName.replace('annot_', ''));

                                    // åœ¨ state.annotations ä¸­æ‰¾åˆ°å¹¶æ›´æ–°
                                    // æ³¨æ„ï¼šè¿™é‡Œå¯èƒ½æœ‰å¤šæ¡æ ‡æ³¨æ—¶é—´ç›¸åŒï¼Œç®€å•èµ·è§åŒ¹é…æ—¶é—´
                                    // æ›´ä¸¥è°¨åº”è¯¥ç”¨å”¯ä¸€ IDï¼Œä½†ç›®å‰åªæœ‰æ—¶é—´
                                    const targetAnnot = state.annotations.find(a => Math.abs(a.time_sec - oldTimeSec) < 0.001);

                                    if (targetAnnot) {
                                        // è®¡ç®—æ–°çš„æ—¶é—´ (å¦‚æœæ˜¯ Date å¯¹è±¡éœ€è½¬æ¢ï¼Œå¦‚æœæ˜¯çº¿æ€§å€¼ç›´æ¥ç”¨)
                                        // æˆ‘ä»¬çš„ x æ˜¯ç»å¯¹æ—¶é—´ (Date) æˆ– ç›¸å¯¹æ—¶é—´ (sec)
                                        let newTimeSec = newX;

                                        // å¦‚æœæ˜¯ Date å­—ç¬¦ä¸²æˆ–å¯¹è±¡
                                        if (typeof newX === 'string' || newX instanceof Date) {
                                            const newDate = new Date(newX);
                                            const recordStart = state.metadata?.attributes?.Timestamp ||
                                                state.metadata?.attributes?.timestamp || 0;
                                            if (recordStart) {
                                                newTimeSec = (newDate.getTime() / 1000) - recordStart;
                                            }
                                        }

                                        console.log(`Annotation Moved: ${oldTimeSec.toFixed(3)}s -> ${newTimeSec.toFixed(3)}s`);
                                        targetAnnot.time_sec = newTimeSec;
                                        annotationMoved = true;
                                    }
                                }
                            }
                        }
                    });

                    if (annotationMoved) {
                        renderAnnotationList(); // æ›´æ–°ä¾§è¾¹æ 
                        // ä¸ä¸€å®šè¦é‡ç»˜æ•´ä¸ªæ³¢å½¢ï¼Œé™¤ééœ€è¦æ›´æ–°æ ‡æ³¨çš„ name (id)
                        // æš‚æ—¶ä¸é‡ç»˜ï¼Œç­‰å¾…ç”¨æˆ·ä¸‹æ¬¡æ“ä½œæˆ–é˜²æŠ–
                        // æˆ–è€…ä»…æ›´æ–° layout.annotations çš„ name? 
                        // ä¸ºäº†ä¿æŒä¸€è‡´æ€§ï¼Œè¿˜æ˜¯å»ºè®®é‡ç»˜ï¼Œå¦åˆ™ä¸‹æ¬¡å†æ‹–åŒä¸€ä¸ªæ—§ name ä¼šæ‰¾ä¸åˆ°
                        // ä½†é‡ç»˜ä¼šå¯¼è‡´æ‹–æ‹½â€œé—ªçƒâ€æˆ–é‡ç½®äº¤äº’ï¼Œä½“éªŒä¸å¥½ã€‚
                        // å¦¥åï¼šåªæ›´æ–°åˆ—è¡¨ï¼Œä¸é‡ç»˜æ³¢å½¢ï¼Œåæ­£ name å…¶å®å¯ä»¥ä¸æ›´æ–°ï¼Œåªè¦å†…å­˜é‡Œçš„ state æ›´æ–°äº†å°±è¡Œã€‚
                        // ä½†ç­‰ä¸€ä¸‹ï¼Œå¦‚æœä¸æ›´æ–° nameï¼Œä¸‹æ¬¡æ‹–æ‹½ eventData è¿˜æ˜¯æ—§ nameï¼Œè¿˜æ˜¯èƒ½æ‰¾åˆ°æ—§ timeã€‚
                        // é—®é¢˜æ˜¯ targetAnnot.time_sec å·²ç»å˜äº†ã€‚find ä¼šå¤±è´¥ã€‚
                        // æ‰€ä»¥å¿…é¡»é‡ç»˜ï¼Œæˆ–è€…æ›´æ–° layout ä¸­çš„ nameã€‚

                        // ç®€å•èµ·è§ï¼šåˆ·æ–°æ•´ä¸ªå›¾è¡¨ (å¯èƒ½ä½“éªŒç¨é¡¿)
                        setTimeout(() => loadAndRenderData(), 50);
                    }
                });

                // ç‚¹å‡»å·¦ä¾§é€šé“ååˆ‡æ¢æ˜¾ç¤º/éšè—ï¼Œæˆ–ç‚¹å‡»æ ‡æ³¨è·³è½¬
                plotDiv.on('plotly_clickannotation', function (eventData) {
                    const annotName = eventData.annotation.name;

                    // æ ‡æ³¨ç‚¹å‡»è·³è½¬
                    if (annotName && annotName.startsWith('annot_')) {
                        const timeSec = parseFloat(annotName.replace('annot_', ''));
                        if (!isNaN(timeSec)) {
                            jumpToTime(timeSec);
                        }
                        return;
                    }

                    // é€šé“åç‚¹å‡»åˆ‡æ¢æ˜¾ç¤º/éšè—
                    if (annotName && annotName.startsWith('ch-')) {
                        const traceIndex = parseInt(annotName.split('-')[1]);
                        // åˆ‡æ¢ trace çš„å¯è§æ€§
                        const currentVisibility = plotDiv.data[traceIndex].visible;
                        const newVisibility = (currentVisibility === true || currentVisibility === undefined) ? 'legendonly' : true;

                        Plotly.restyle(plotDiv, { visible: newVisibility }, [traceIndex]);

                        // æ›´æ–° annotation æ ·å¼æ˜¾ç¤ºéšè—çŠ¶æ€
                        const annotIndex = plotDiv.layout.annotations.findIndex(a => a.name === annotName);
                        if (annotIndex !== -1) {
                            const newOpacity = newVisibility === true ? 1 : 0.3;
                            Plotly.relayout(plotDiv, {
                                [`annotations[${annotIndex}].font.color`]: newVisibility === true
                                    ? CHANNEL_COLORS[traceIndex % CHANNEL_COLORS.length]
                                    : '#555'
                            });
                        }
                    }
                });
            }
        }

        // [NEW] æ³¢å½¢åŒºåŸŸå³é”®èœå• - ç”¨äºè®¾ç½®å•é€šé“æ»¤æ³¢
        // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç¡®ä¿åœ¨ Plotly åŠ¨æ€æ¸²æŸ“åä¹Ÿèƒ½æ­£å¸¸å·¥ä½œ
        document.addEventListener('contextmenu', function (event) {
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨ ecg-plot åŒºåŸŸå†…
            const plotDiv = document.getElementById('ecg-plot');
            if (!plotDiv || !plotDiv.contains(event.target)) return;

            // åªè¦åœ¨ ecg-plot åŒºåŸŸå†…ï¼Œå°±é˜»æ­¢é»˜è®¤å³é”®èœå•
            event.preventDefault();
            event.stopPropagation();

            // æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®
            if (!state.metadata || state.activeChannels.length === 0) {
                console.log('æ— æ•°æ®ï¼Œè·³è¿‡é€šé“èœå•');
                return;
            }

            // è·å– Plotly å›¾è¡¨åŒºåŸŸä¿¡æ¯
            const plotLayout = plotDiv._fullLayout;
            const plotBBox = plotDiv.querySelector('.nsewdrag')?.getBoundingClientRect();

            if (!plotLayout || !plotBBox) {
                console.log('Plotly æœªæ¸²æŸ“ï¼Œè·³è¿‡é€šé“èœå•');
                return;
            }

            // è®¡ç®—ç›¸å¯¹äºå›¾è¡¨åŒºåŸŸçš„ Y ä½ç½®
            const relativeY = event.clientY - plotBBox.top;
            const plotHeight = plotBBox.height;

            // è€ƒè™‘åˆ†é¡µï¼šè·å–å½“å‰é¡µæ˜¾ç¤ºçš„é€šé“
            const startIndex = state.currentPage * state.channelsPerPage;
            const endIndex = Math.min(startIndex + state.channelsPerPage, state.activeChannels.length);
            const visibleChannelCount = endIndex - startIndex;

            // æ ¹æ® Y ä½ç½®åˆ¤æ–­ç‚¹å‡»äº†å“ªä¸ªé€šé“ (å‡è®¾é€šé“å‡åŒ€åˆ†å¸ƒ)
            const channelHeight = plotHeight / visibleChannelCount;
            const clickedVisibleIndex = Math.floor(relativeY / channelHeight);

            // ç¡®ä¿ç´¢å¼•æœ‰æ•ˆ
            const validVisibleIndex = Math.max(0, Math.min(clickedVisibleIndex, visibleChannelCount - 1));
            // è½¬æ¢ä¸ºå®é™…çš„é€šé“ç´¢å¼•
            const channelIdx = state.activeChannels[startIndex + validVisibleIndex];
            const displayNames = state.metadata.display_channel_names || state.metadata.channel_names;
            const channelName = displayNames[channelIdx] || `Ch${channelIdx + 1}`;

            console.log(`å³é”®ç‚¹å‡»é€šé“: ${channelName} (ç´¢å¼•: ${channelIdx}, é¡µå†…ä½ç½®: ${validVisibleIndex})`);

            // æ˜¾ç¤ºå³é”®èœå•
            showChannelContextMenu(event, channelIdx, channelName);
        }, true); // ä½¿ç”¨æ•è·é˜¶æ®µ

        // ========== æ§åˆ¶å‡½æ•° ==========
        function toggleChannel(index) {
            const pos = state.activeChannels.indexOf(index);
            if (pos > -1) {
                if (state.activeChannels.length > 1) {
                    state.activeChannels.splice(pos, 1);
                }
            } else {
                state.activeChannels.push(index);
                state.activeChannels.sort((a, b) => a - b);
            }

            renderChannelList();
            updatePaginationUI(); // æ›´æ–°åˆ†é¡µä¿¡æ¯
            loadAndRenderData();
        }

        function toggleAllChannels() {
            const totalChannels = state.metadata.display_num_channels || state.metadata.num_channels;
            if (state.activeChannels.length === totalChannels) {
                state.activeChannels = [0];
            } else {
                state.activeChannels = Array.from({ length: totalChannels }, (_, i) => i);
            }

            renderChannelList();
            updatePaginationUI(); // æ›´æ–°åˆ†é¡µä¿¡æ¯
            loadAndRenderData();
        }

        function toggleGrid() {
            state.showGrid = !state.showGrid;
            if (state.currentData) {
                renderWaveforms(state.currentData);
            }
            showToast(state.showGrid ? 'ç½‘æ ¼å·²æ˜¾ç¤º' : 'ç½‘æ ¼å·²éšè—');
        }

        function toggleDisplayMode() {
            state.displayMode = state.displayMode === 'stacked' ? 'overlay' : 'stacked';
            if (state.currentData) {
                renderWaveforms(state.currentData);
            }
            showToast(state.displayMode === 'stacked' ? 'å †å æ˜¾ç¤ºæ¨¡å¼' : 'å åŠ æ˜¾ç¤ºæ¨¡å¼');
        }

        function toggleSmoothing() {
            const checkbox = document.getElementById('smoothing-toggle');
            state.enableSmoothing = checkbox.checked;
            if (state.currentData) {
                renderWaveforms(state.currentData);
            }
            showToast(state.enableSmoothing ? 'ä»¥å¼€å¯å¾®å¹³æ»‘' : 'å·²å…³é—­å¾®å¹³æ»‘ (åŸå§‹é”åº¦)');
        }

        function resetView() {
            if (!state.metadata) return;

            state.viewStart = 0;
            // æ ¹æ®å½“å‰é€Ÿåº¦è®¡ç®—åˆå§‹æ—¶é—´çª—
            const screenWidthMm = 400;
            const initialRange = screenWidthMm / (state.speed || 25);
            state.viewEnd = Math.min(initialRange, state.metadata.duration_seconds);
            state.zoomLevel = 1;
            loadAndRenderData();
        }

        // æ ¼å¼åŒ–ç›¸å¯¹ç§’ä¸ºç»å¯¹æ—¶é—´ HH:MM:SS
        function formatAbsoluteTimeForInput(relativeSec) {
            const recordStartTimestamp = state.metadata?.attributes?.Timestamp ||
                state.metadata?.attributes?.timestamp ||
                state.metadata?.Timestamp ||
                state.metadata?.timestamp || 0;
            if (!recordStartTimestamp) {
                return relativeSec.toFixed(2) + 's';
            }
            const d = new Date((recordStartTimestamp + relativeSec) * 1000);
            return d.toLocaleTimeString('en-GB', { hour12: false }); // HH:MM:SS
        }

        // è§£æç»å¯¹æ—¶é—´å›ç›¸å¯¹ç§’
        function parseAbsoluteTimeFromInput(timeStr) {
            if (!timeStr) return 0;

            const recordStartTimestamp = state.metadata?.attributes?.Timestamp ||
                state.metadata?.attributes?.timestamp ||
                state.metadata?.Timestamp ||
                state.metadata?.timestamp || 0;

            // å°è¯•è§£æ HH:MM:SS æˆ– HH:MM:SS.sss
            const match = timeStr.match(/^(\d{1,2}):(\d{2}):(\d{2})(\.\d+)?$/);
            if (match && recordStartTimestamp) {
                const h = parseInt(match[1]);
                const m = parseInt(match[2]);
                const sInt = parseInt(match[3]);
                const sFrac = match[4] ? parseFloat(match[4]) : 0;
                const s = sInt + sFrac;

                // ä»å½•åˆ¶å¼€å§‹æ—¶é—´è·å–æ—¥æœŸéƒ¨åˆ†
                const baseDate = new Date(recordStartTimestamp * 1000);
                const targetDate = new Date(baseDate);
                targetDate.setHours(h, m, sInt, Math.round(sFrac * 1000));
                // è®¡ç®—ç›¸å¯¹ç§’æ•°
                const result = (targetDate.getTime() / 1000) - recordStartTimestamp;
                return isNaN(result) ? 0 : result;
            }
            // å›é€€ï¼šå°è¯•è§£æä¸ºçº¯æ•°å­— (ç§’)
            const parsed = parseFloat(timeStr.replace(/s$/i, ''));
            return isNaN(parsed) ? 0 : parsed;
        }

        function updateViewRange() {
            const startInput = document.getElementById('view-start-input');
            const endInput = document.getElementById('view-end-input');
            if (startInput) startInput.value = formatAbsoluteTimeForInput(state.viewStart);
            if (endInput) endInput.value = formatAbsoluteTimeForInput(state.viewEnd);
        }

        // æ‰‹åŠ¨è·³è½¬åˆ°æŒ‡å®šèŒƒå›´
        function jumpToStartTime() {
            const startInput = document.getElementById('view-start-input');
            if (!startInput || !state.metadata) return;

            let start = parseAbsoluteTimeFromInput(startInput.value);

            // ä¿æŒå½“å‰è§†å›¾æ—¶é•¿
            const viewDuration = state.viewEnd - state.viewStart;
            const duration = state.metadata.duration_seconds;

            start = Math.max(0, Math.min(start, duration - viewDuration));

            state.viewStart = start;
            state.viewEnd = Math.min(duration, start + viewDuration);

            updateViewRange();
            loadAndRenderData();
        }

        // ä¿ç•™åŸå‡½æ•°ç”¨äºå…¶ä»–è°ƒç”¨
        function jumpToRange() {
            jumpToStartTime();
        }

        function zoomIn() {
            if (!state.metadata) return;

            const center = (state.viewStart + state.viewEnd) / 2;
            const halfRange = (state.viewEnd - state.viewStart) / 4;

            state.viewStart = Math.max(0, center - halfRange);
            state.viewEnd = Math.min(state.metadata.duration_seconds, center + halfRange);

            loadAndRenderData();
        }

        function zoomOut() {
            if (!state.metadata) return;

            const center = (state.viewStart + state.viewEnd) / 2;
            const halfRange = (state.viewEnd - state.viewStart);

            state.viewStart = Math.max(0, center - halfRange);
            state.viewEnd = Math.min(state.metadata.duration_seconds, center + halfRange);

            loadAndRenderData();
        }

        function panLeft() {
            if (!state.metadata) return;

            const range = state.viewEnd - state.viewStart;
            const step = 0.01; // å›ºå®šæ­¥è¿› 0.01 ç§’

            state.viewStart = Math.max(0, state.viewStart - step);
            state.viewEnd = state.viewStart + range;

            loadAndRenderData(false);
        }

        function panRight() {
            if (!state.metadata) return;

            const range = state.viewEnd - state.viewStart;
            const step = 0.01; // å›ºå®šæ­¥è¿› 0.01 ç§’

            state.viewEnd = Math.min(state.metadata.duration_seconds, state.viewEnd + step);
            state.viewStart = state.viewEnd - range;

            loadAndRenderData(false);
        }

        function panLeftFast() {
            if (!state.metadata) return;

            const range = state.viewEnd - state.viewStart;
            const step = 1; // å›ºå®šæ­¥è¿› 1 ç§’

            state.viewStart = Math.max(0, state.viewStart - step);
            state.viewEnd = state.viewStart + range;

            loadAndRenderData(false);
        }

        function panRightFast() {
            if (!state.metadata) return;

            const range = state.viewEnd - state.viewStart;
            const step = 1; // å›ºå®šæ­¥è¿› 1 ç§’

            state.viewEnd = Math.min(state.metadata.duration_seconds, state.viewEnd + step);
            state.viewStart = state.viewEnd - range;

            loadAndRenderData(false);
        }

        function fitToWindow() {
            if (!state.metadata) return;

            state.viewStart = 0;
            state.viewEnd = state.metadata.duration_seconds;

            loadAndRenderData();
        }

        function jumpToTime(time) {
            if (!state.metadata) return;

            const range = state.viewEnd - state.viewStart;
            const offset = range * 0.1;  // æ ‡æ³¨æ”¾åœ¨è§†å›¾èµ·å§‹ä½ç½®å 10% å¤„

            state.viewStart = Math.max(0, time - offset);
            state.viewEnd = Math.min(state.metadata.duration_seconds, state.viewStart + range);

            if (state.viewEnd > state.metadata.duration_seconds) {
                state.viewEnd = state.metadata.duration_seconds;
                state.viewStart = Math.max(0, state.viewEnd - range);
            }

            updateViewRange();
            loadAndRenderData();
            console.log(`è·³è½¬åˆ°æ—¶é—´: ${time.toFixed(2)}s, è§†å›¾èŒƒå›´: ${state.viewStart.toFixed(2)} - ${state.viewEnd.toFixed(2)}`);
        }

        // ========== å¯¼å‡ºåŠŸèƒ½ ==========
        async function exportImage() {
            if (!state.currentData) {
                showToast('æ— æ•°æ®å¯å¯¼å‡º', 'error');
                return;
            }
            try {
                const plotDiv = document.getElementById('ecg-plot');
                if (!plotDiv || !plotDiv.data || plotDiv.data.length === 0) {
                    showToast('å›¾è¡¨æœªæ¸²æŸ“ï¼Œæ— æ³•å¯¼å‡º', 'error');
                    return;
                }
                showToast('æ­£åœ¨å¯¼å‡ºå›¾ç‰‡...', 'info');

                // è·å–å›¾ç‰‡æ•°æ®
                const dataUrl = await Plotly.toImage(plotDiv, {
                    format: 'png',
                    width: plotDiv.clientWidth || 1920,
                    height: plotDiv.clientHeight || 1080
                });

                // ç›´æ¥ä½¿ç”¨ data URL ä¸‹è½½
                const link = document.createElement('a');
                link.href = dataUrl;
                link.download = `ecg_export_${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.png`;
                link.click();

                showToast('å›¾ç‰‡å·²å¯¼å‡º', 'success');
            } catch (err) {
                console.error('Export failed:', err);
                showToast('å¯¼å‡ºå¤±è´¥: ' + (err.message || 'æœªçŸ¥é”™è¯¯'), 'error');
            }
        }

        function exportCSV() {
            if (!state.currentData) {
                showToast('æ— æ•°æ®å¯å¯¼å‡º', 'error');
                return;
            }

            const data = state.currentData;
            let csv = 'æ—¶é—´(ç§’),' + data.channel_names.join(',') + '\n';

            for (let i = 0; i < data.time.length; i++) {
                const row = [data.time[i].toFixed(4)];
                for (let j = 0; j < data.channel_names.length; j++) {
                    row.push(data.data[i][j].toFixed(4));
                }
                csv += row.join(',') + '\n';
            }

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `ecg_${state.viewStart.toFixed(1)}-${state.viewEnd.toFixed(1)}s.csv`;
            link.click();

            showToast('CSV å·²å¯¼å‡º', 'success');
        }

        // ========== åˆå§‹åŒ– ==========
        document.addEventListener('DOMContentLoaded', () => {
            // æ£€æŸ¥ API å¯ç”¨æ€§
            fetch('/api/ecg/check')
                .then(r => r.json())
                .then(data => {
                    if (!data.h5py_available) {
                        showToast('è­¦å‘Š: h5py æœªå®‰è£…ï¼Œéƒ¨åˆ†åŠŸèƒ½ä¸å¯ç”¨', 'warning');
                    }
                })
                .catch(() => {
                    showToast('ECG API ä¸å¯ç”¨', 'error');
                });
        });

        // å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') panLeft();
            else if (e.key === 'ArrowRight') panRight();
            else if (e.key === '+' || e.key === '=') zoomIn();
            else if (e.key === '-') zoomOut();
            else if (e.key === 'r' || e.key === 'R') resetView();
            else if (e.key === 'g' || e.key === 'G') toggleGrid();
        });
    </script>

    <!-- Channel Right-Click Filter Menu (Horizontal Bar Style) -->
    <div id="channel-context-menu" class="channel-context-menu">
        <div class="menu-header">ğŸ›ï¸ <span id="ctx-channel-name"></span></div>
        <div class="menu-row">
            <label>Amplitude:</label>
            <select id="ctx-amplitude-select">
                <option value="">Auto</option>
                <option value="0.1">0.1 mV/cm</option>
                <option value="0.2">0.2 mV/cm</option>
                <option value="0.3">0.3 mV/cm</option>
                <option value="0.4">0.4 mV/cm</option>
                <option value="0.5">0.5 mV/cm</option>
                <option value="1">1.0 mV/cm</option>
                <option value="2">2.0 mV/cm</option>
                <option value="3">3.0 mV/cm</option>
                <option value="4">4.0 mV/cm</option>
                <option value="5">5.0 mV/cm</option>
                <option value="10">10 mV/cm</option>
                <option value="20">20 mV/cm</option>
                <option value="50">50 mV/cm</option>
                <option value="100">100 mV/cm</option>
            </select>
        </div>
        <div class="menu-row">
            <label>Clipping:</label>
            <select id="ctx-clipping-select">
                <option value="">Off</option>
                <option value="1">1 cm</option>
                <option value="2">2 cm</option>
                <option value="3">3 cm</option>
                <option value="4">4 cm</option>
                <option value="5">5 cm</option>
                <option value="6">6 cm</option>
                <option value="7">7 cm</option>
                <option value="8">8 cm</option>
                <option value="9">9 cm</option>
                <option value="10">10 cm</option>
            </select>
        </div>
        <div class="menu-row">
            <label>High Pass:</label>
            <select id="ctx-hp-select">
                <option value="">DC</option>
                <option value="0.05">0.05 Hz</option>
                <option value="0.5">0.5 Hz</option>
                <option value="1">1 Hz</option>
                <option value="2">2 Hz</option>
                <option value="5">5 Hz</option>
                <option value="10">10 Hz</option>
                <option value="20">20 Hz</option>
                <option value="30">30 Hz</option>
                <option value="40">40 Hz</option>
                <option value="50">50 Hz</option>
                <option value="60">60 Hz</option>
                <option value="80">80 Hz</option>
                <option value="100">100 Hz</option>
                <option value="200">200 Hz</option>
            </select>
        </div>
        <div class="menu-row">
            <label>Low Pass:</label>
            <select id="ctx-lp-select">
                <option value="">Off</option>
                <option value="10">10 Hz</option>
                <option value="20">20 Hz</option>
                <option value="30">30 Hz</option>
                <option value="40">40 Hz</option>
                <option value="50">50 Hz</option>
                <option value="60">60 Hz</option>
                <option value="80">80 Hz</option>
                <option value="100">100 Hz</option>
                <option value="200">200 Hz</option>
                <option value="300">300 Hz</option>
                <option value="400">400 Hz</option>
                <option value="500">500 Hz</option>
            </select>
        </div>
        <div class="menu-actions">
            <button class="btn-cancel" onclick="hideChannelContextMenu()">âœ•</button>
            <button class="btn-apply" onclick="applyChannelFilter()">Apply</button>
        </div>
    </div>

    <script>
        // ========== é€šé“å³é”®èœå•é€»è¾‘ ==========
        let contextMenuChannelIndex = null;
        let contextMenuClickHandler = null;

        function showChannelContextMenu(event, channelIndex, channelName) {
            event.preventDefault();
            event.stopPropagation();

            contextMenuChannelIndex = channelIndex;
            const menu = document.getElementById('channel-context-menu');
            document.getElementById('ctx-channel-name').textContent = channelName;

            // åŠ è½½å½“å‰é€šé“çš„è®¾ç½®
            const filter = state.channelFilters?.[channelIndex] || {};
            document.getElementById('ctx-lp-select').value = filter.lp || '';
            document.getElementById('ctx-hp-select').value = filter.hp || '';
            document.getElementById('ctx-amplitude-select').value = filter.amplitude || '';
            document.getElementById('ctx-clipping-select').value = filter.clipping || '';

            // å®šä½èœå•
            menu.style.left = event.clientX + 'px';
            menu.style.top = event.clientY + 'px';
            menu.classList.add('visible');

            // ç§»é™¤ä¹‹å‰çš„ç›‘å¬å™¨ï¼ˆå¦‚æœæœ‰ï¼‰
            if (contextMenuClickHandler) {
                document.removeEventListener('click', contextMenuClickHandler);
            }

            // ç‚¹å‡»èœå•å¤–éƒ¨å…³é—­èœå•
            contextMenuClickHandler = function (e) {
                const menu = document.getElementById('channel-context-menu');
                if (!menu.contains(e.target)) {
                    hideChannelContextMenu();
                    document.removeEventListener('click', contextMenuClickHandler);
                    contextMenuClickHandler = null;
                }
            };

            // å»¶è¿Ÿæ·»åŠ ç›‘å¬å™¨ï¼Œé¿å…ç«‹å³è§¦å‘
            setTimeout(() => {
                document.addEventListener('click', contextMenuClickHandler);
            }, 50);
        }

        function hideChannelContextMenu() {
            document.getElementById('channel-context-menu').classList.remove('visible');
            contextMenuChannelIndex = null;
            if (contextMenuClickHandler) {
                document.removeEventListener('click', contextMenuClickHandler);
                contextMenuClickHandler = null;
            }
        }

        async function applyChannelFilter() {
            if (contextMenuChannelIndex === null) return;

            const lp = document.getElementById('ctx-lp-select').value;
            const hp = document.getElementById('ctx-hp-select').value;
            const amplitude = document.getElementById('ctx-amplitude-select').value;
            const clipping = document.getElementById('ctx-clipping-select').value;

            // ä¿å­˜é€šé“ä¿¡æ¯ï¼ˆåœ¨ hideChannelContextMenu ä¹‹å‰è·å–ï¼‰
            const savedChannelIndex = contextMenuChannelIndex;
            const chName = state.metadata?.display_channel_names?.[savedChannelIndex] || `Ch${savedChannelIndex + 1}`;

            // åˆå§‹åŒ– channelFilters
            if (!state.channelFilters) state.channelFilters = {};

            // ä¿å­˜è®¾ç½®
            if (lp || hp || amplitude || clipping) {
                state.channelFilters[savedChannelIndex] = { lp, hp, amplitude, clipping };
            } else {
                delete state.channelFilters[savedChannelIndex];
            }

            hideChannelContextMenu();
            renderChannelList(); // æ›´æ–°é€šé“åˆ—è¡¨æ˜¾ç¤º
            await loadAndRenderData(); // ç­‰å¾…æ•°æ®é‡æ–°åŠ è½½

            const parts = [];
            if (hp) parts.push(`HP=${hp}Hz`);
            if (lp) parts.push(`LP=${lp}Hz`);
            if (amplitude) parts.push(`Amp=${amplitude}mV/cm`);
            if (clipping) parts.push(`Clip=${clipping}cm`);
            showToast(`${chName}: ${parts.length > 0 ? parts.join(', ') : 'é»˜è®¤è®¾ç½®'}`, 'success');
        }

        // åˆå§‹åŒ– UI çŠ¶æ€
        document.addEventListener('DOMContentLoaded', () => {
            // åŒæ­¥ filterMethod ä¸‹æ‹‰æ¡†
            const filterMethodSelect = document.getElementById('filter-method-select');
            if (filterMethodSelect && state.filterMethod) {
                filterMethodSelect.value = state.filterMethod;
            }
        });
    </script>
</body>

</html>